[
["index.html", "PSYC6060 Course Notes Preface Structure of the book Software information and conventions", " PSYC6060 Course Notes David J. Stanley 2020-06-25 Preface R’s emerging role in psychology will be described here.. Structure of the book I’ll put more about the structure of the book here in the future. Software information and conventions I used the knitr package (Xie 2015) and the bookdown package (Xie 2020) to compile my book. My R session information is shown below: xfun::session_info() ## R version 4.0.1 (2020-06-06) ## Platform: x86_64-apple-darwin17.0 (64-bit) ## Running under: macOS Catalina 10.15.5, RStudio 1.3.959 ## ## Locale: en_CA.UTF-8 / en_CA.UTF-8 / en_CA.UTF-8 / C / en_CA.UTF-8 / en_CA.UTF-8 ## ## Package version: ## askpass_1.1 assertthat_0.2.1 ## backports_1.1.7 base64enc_0.1.3 ## BH_1.72.0.3 bookdown_0.19.1 ## broom_0.7.0.9000 callr_3.4.3 ## cellranger_1.1.0 cli_2.0.2 ## clipr_0.7.0 colorspace_1.4-1 ## compiler_4.0.1 crayon_1.3.4 ## curl_4.3 DBI_1.1.0 ## dbplyr_1.4.3 desc_1.2.0 ## digest_0.6.25 dplyr_1.0.0 ## ellipsis_0.3.1 evaluate_0.14 ## fansi_0.4.1 farver_2.0.3 ## forcats_0.5.0 fs_1.4.1 ## generics_0.0.2 ggplot2_3.3.1 ## glue_1.4.1 graphics_4.0.1 ## grDevices_4.0.1 grid_4.0.1 ## gtable_0.3.0 haven_2.3.1 ## highr_0.8 hms_0.5.3 ## htmltools_0.4.0 httr_1.4.1 ## isoband_0.2.1 janitor_2.0.1 ## jsonlite_1.6.1 knitr_1.28 ## labeling_0.3 lattice_0.20-41 ## lifecycle_0.2.0 lubridate_1.7.8 ## magrittr_1.5 markdown_1.1 ## MASS_7.3.51.6 Matrix_1.2.18 ## methods_4.0.1 mgcv_1.8.31 ## mime_0.9 mnormt_1.5-7 ## modelr_0.1.8 munsell_0.5.0 ## nlme_3.1-148 openssl_1.4.1 ## packrat_0.5.0 parallel_4.0.1 ## pillar_1.4.4 pkgbuild_1.0.8 ## pkgconfig_2.0.3 pkgload_1.1.0 ## praise_1.0.0 prettyunits_1.1.1 ## processx_3.4.2 progress_1.2.2 ## ps_1.3.3 psych_1.9.12.31 ## purrr_0.3.4 R6_2.4.1 ## RColorBrewer_1.1.2 Rcpp_1.0.4.6 ## readr_1.3.1 readxl_1.3.1 ## rematch_1.0.1 reprex_0.3.0 ## rlang_0.4.6 rmarkdown_2.2 ## rprojroot_1.3.2 rsconnect_0.8.16 ## rstudioapi_0.11 rvest_0.3.5 ## scales_1.1.1 selectr_0.4.2 ## snakecase_0.11.0 splines_4.0.1 ## stats_4.0.1 stringi_1.4.6 ## stringr_1.4.0 sys_3.3 ## testthat_2.3.2 tibble_3.0.1 ## tidyr_1.1.0 tidyselect_1.1.0 ## tidyverse_1.3.0 tinytex_0.23 ## tools_4.0.1 utf8_1.1.4 ## utils_4.0.1 vctrs_0.3.0 ## viridisLite_0.3.0 whisker_0.4 ## withr_2.2.0 xfun_0.14 ## xml2_1.3.2 yaml_2.2.1 Package names are in bold text (e.g., rmarkdown), and inline code and filenames are formatted in a typewriter font (e.g., knitr::knit('foo.Rmd')). Function names are followed by parentheses (e.g., bookdown::render_book()). References "],
["about-the-author.html", "About the Author", " About the Author David J. Stanley is an Associate Professor of Industrial and Organizational Psychology at the University of Guelph in Canada. He obtained his PhD from Western University in London, Ontario. David has published articles in Advances in Methods and Practices in Psychological Science, Organizational Research Methods, Journal of Applied Psychology, Perspectives in Psychological Science, Journal of Business and Psychology, Journal of Vocational Behaviour, Journal of Personality and Social Psychology, Behavior Research Methods, Industrial and Organizational Psychology, and Emotion among other journals. David also created the apaTables R package. "],
["introduction.html", "Chapter 1 Introduction 1.1 SHIFT RETURN SOMEWHERE 1.2 A focus on workflow 1.3 R works with plug-ins 1.4 Create an account at R Studio Cloud 1.5 Join the class workspace 1.6 Exploring the R Studio Interface 1.7 Writing your first script 1.8 Loading your data 1.9 Checking out your data 1.10 Run vs. Source with Echo vs. Source 1.11 Trying Source with Echo 1.12 A Few Key Points About R 1.13 That’s it!", " Chapter 1 Introduction 1.1 SHIFT RETURN SOMEWHERE Welcome! In this guide, we will teach you about statistics using the statistical software R with the interface provided by R Studio. The purpose of this chapter to is provide you with a set of activities that get you up-and-running in R quickly so get a sense of how it works. In later chatpers we will revisit these same topics in more detail. 1.2 A focus on workflow An important part of this guide is training you in a workflow that will avoid many problems than can occur when using R. 1.3 R works with plug-ins R is a statistical language with many plug-ins called packages that you will use for analyses. You can think of R as being like your smartphone. To do things with your phone you need an App (R equivalent: a package) from the App Store (R equivalent: CRAN). Apps need to be downloaded (R equivalent: install.packages) before you can use them. To use the app you need Open it (R equivalent: library command). These similarities are illustrated in Table 1.1 below. TABLE 1.1: R packages are similar to smart phone apps (Kim, 2018) Smart Phone Terminology R Terminology App package App Store CRAN Download App from App Store install.packages(“apaTables”, dependencies = TRUE) Open App library(“apaTables”) 1.4 Create an account at R Studio Cloud R Studio Cloud accounts are free and required for this guide. Please go to the website and set up a new account. 1.5 Join the class workspace To do the assignment required for this class you need to join the class workspace on R Studio Cloud. To do so: Log into R Studio Cloud (if you haven’t already done so). Go to your university email account and find the message with the subject “R Studio Workspace Invitation”. In this message there is a link to the class R Studio Cloud workspace. Click on the workspace link in the email or paste it into your web browser. You should see a screen like the one below in Figure 1.1. Click on the Join button. FIGURE 1.1: Screen shot of workspace join message. Then you should see the welcome message illustrated in Figure 1.2. Above this message is the Projects menu option. Click on the word Project. FIGURE 1.2: Screen shot of welcome messag You should now see the First Project displayed as in 1.3. Click the Start button. You will then move to a view of R Studio. FIGURE 1.3: Screen shot of starting first assignment In R Studio it is essential you use projects to keep your files organized and in the same spot. For this course, when your start an assignment on R Studio Cloud and the project will already have been made for you. Later you will learn to make your own R Studio Projects. 1.6 Exploring the R Studio Interface Once you have opened (or created) a Project folder, you are presented with the R Studio interface. There are a few key elements to the user interface that are illustrated in Figure 1.4 In the lower right of the screen you can see the a panel with several tabs (i.e., Files, Plots, Packages, etc) that I will refer to as the Files pane. You look in this pane to see all the files associated with your project. On the left side of the screen is the Console which is an interactive pane where you type and obtain results in real time. I’ve placed two large grey blocks on the screen with text to more clearly identify the Console and Files panes. Not shown in this figure is the Script panel where we can store our commands for later reuse. FIGURE 1.4: R Studio interface 1.6.1 Console panel When you first start R, the Console panel is on the left side of the screen. Sometimes there are two panels on the left side (one above the other); if so, the Console panel is the lower one (and labeled accordingly). We can use R a bit like a calculator. Try typing the following into the Console window: 8 + 6 + 7 + 5. You can see that R immediately produced the result on a line preceded by two hashtags (##). 8 + 6 + 7 + 5 ## [1] 26 We can also put the result into a variable to store it. Later we can use the print command to see that result. In the example below we add the numbers 3, 0, and 9 and store the result in the variable my_sum. The text “&lt;-” indicate you are putting what is on the right side of the arrow into the variable on the left side of the arrow. You can think of a variable as cup into which you can put different things. In this case, imagine a real-world cup with my_sum written on the outside and inside the cup we have stored the sum of 3, 0, and 9 (i.e., 12). my_sum &lt;- 3 + 0 + 9 We can inspect the contents of the my_sum variable (i.e., my_sum cup) with the print command: print(my_sum) ## [1] 12 Variable are very useful in R. We will use them to store a single number, an entire data set, the results of an analysis, or anything else. 1.6.2 Script Panel Although you can use R with just with the Console panel, it’s a better idea to use scripts via the Script panel - not visible yet. Scripts are just text files with the commands you use stored in them. You can run a script (as you will see below) using the Run or Source buttons located in the top right of the Script panel. Scripts are valuable because if you need to run an analysis a second time you don’t have to type the command in a second time. You can run the script again and again without retyping your commands. More importantly though, the script provides a record of your analyses. A common problem in science is that after an article is published, the authors can’t reproduce the numbers in the paper. You can read more about the important problem in a surprising article in the journal Molecular Brain. In this article an editor reports how a request for the data underlying articles resulted in the wrong data for 40 out of 41 papers. Long story short – keep track of the data and scripts you use for your paper. In a later chapter, it’s generally poor practice to manipulate or modify or analyze your data using any menu driven software because this approach does not provide a record of what you have done. 1.7 Writing your first script 1.7.1 Create the script file Create a script in your R Studio project by using the menu File &gt; New File &gt; R Script. Save the file with an appropriate name using the File menu. The file will be saved in your Project folder. A common, and good, convention for naming is to start all script names with the word “script” and separate words with an underscore. You might save this first script file with the name “script_my_first_one.R”. The advantage of beginning all script files with the word script is that when you look at your list of files alphabetically, all the script files will cluster together. Likewise, it’s a good idea to save all data files such that they begin with “data_”. This way all the data files will cluster together in your directory view as well. You can see there is already a data file with this convention called “data_okcupid.csv”. You can see as discussed previously, we are trying to instill an effective workflow as you learn R. Using a good naming convention (that is consistent with what others use) is part of the workflow. When you write your scripts it’s a good idea to follow the tidyverse style guide for script names, variable name, file names, and more. 1.7.2 Add a comment to your script In the previous section you created your first script. We begin by adding a comment to the script. A comment is something that will be read by humans rather than the computer/R. You make comments for other people that will read your code and need to understand what you have done. However, realize that you are also making comments for your future self as illustrated in an XKCD cartoon. A good way to start every script is with a comment that includes the date of your script (or even better when you installed your packages, more on this later). Like smartphone apps, packages are updated regularly. Sometimes after a package is updated it will no longer work with an older script. Fortunately, the checkpoint package lets users role back the clock and use older versions of packages. Adding a comment with the date of your script will help future users (including you) to use your script with the same version of the package used when you wrote the script. Dating your script is an important part of an effective and reproducible workflow. # Code written on: YYYY/MM/DD # By: John Smith Note that in the above comment I used the internationally accepted date format order Year/Month/Day. Some people use the mnemonic Your My Dream to remember this order. Wikipedia provides more information about the Internationally Date Format ISO 8601. Moving forward, I suggest you use comments to make your own personal notes in your own code as your write it. 1.7.3 Background about the tidyverse There are generally two broad ways of using R, the older way and the newer way. Using R the older way is refered to as using base R. A more modern approach to using R is the tidyverse. The tidyverse represents a collection of packages the work together to give R a modern workflow. These packages do many things to help the data analyst (loading data, rearranging data, graphing, etc.). We will use the tidyverse approach to R in this guide. A noted the tidyverse is a collection of packges. Each package adds new commands to R. The number of packges and correspondingly the number of new commands added to R by the tidyverse is large. Below is a list of the tidyverse packages: ## [1] &quot;broom&quot; &quot;cli&quot; &quot;crayon&quot; &quot;dbplyr&quot; ## [5] &quot;dplyr&quot; &quot;forcats&quot; &quot;ggplot2&quot; &quot;haven&quot; ## [9] &quot;hms&quot; &quot;httr&quot; &quot;jsonlite&quot; &quot;lubridate&quot; ## [13] &quot;magrittr&quot; &quot;modelr&quot; &quot;pillar&quot; &quot;purrr&quot; ## [17] &quot;readr&quot; &quot;readxl&quot; &quot;reprex&quot; &quot;rlang&quot; ## [21] &quot;rstudioapi&quot; &quot;rvest&quot; &quot;stringr&quot; &quot;tibble&quot; ## [25] &quot;tidyr&quot; &quot;xml2&quot; &quot;tidyverse&quot; Before you can use a package it needs to be installed – this is the same as downloading an app from the App Store. Normally, you can install a single packages with the install.packages command. Previously, you needed run an install.package command for every package in the tidyverse as illustrated below (though we no longer use this approach). # The old way of installing the tidyverse packages # Like downloading apps from the app store install.packages(&quot;broom&quot;, dep = TRUE) install.packages(&quot;cli&quot;, dep = TRUE) install.packages(&quot;ggplot&quot;, dep = TRUE) # etc Fortunately, the tidyverse packages can now by installed with a single install.packages command. Specifically, the install.packages command below will install all of the packages listed above. Class note: For the “First Lab”, I’ve done the install.packages for you. So there is no need to use the install.packages command below in this first lab. install.packages(&quot;tidyverse&quot;, dep = TRUE) 1.7.4 Add library(tidyverse) to your script The tidyverse is now installed, so we need to activate it. We do that with the library command. Put the library line below at the top of your script file (below your comment): # Code written on: YYYY/MM/DD # By: John Smith library(tidyverse) 1.7.5 Activate tidyverse auto-complete for your script Select the library(tidyverse) text with your mouse/track-pad so that it is highlighted. Then click the Run button in the upper right of the Script panel. Doing this “runs” the selected text. After you click the Run button you should see text like the following the Console panel: When you use library(tidyverse) to activate the tidyverse you activate the most commonly used subset of the tidyverse packages. In the output you see checkmarks beside names of the tidyverse packages you have activated. By activating these packages you have added new commands to R that you will use. Sometimes these packages replace older versions of commands in R. The “Conflicts” section in the output shows you where the packages you activated replaced older R commands with newer R commands. You can activate the other tidyverse package by running a library command for each package – if needed. No need to do so now. Most importantly, running the library(tidyverse) prior to entering the rest of your script allows R Studio to present auto-complete options when typing your text. Remember to start each script with the library(tidyverse) command and then Run it so you get the autocomplete options for the rest of the commands your enter. 1.8 Loading your data 1.8.1 Use read_csv (not read.csv) to open files. If you inspect the Files pane on the right of the screen you see the data_okcupid.csv data file in our project directory. We will load this data with the commands below. If you followed the steps above, you should have auto-complete for the tidyverse commands you type for now in – in the current R session. Enter the command below into your script. As your start to type read_csv you will likely be presented with an auto-complete option. You can use the arrow keys to move up and down the list of options to select the one you want - then press tab to select it. Once your command looks like the one below select the text and click on the “Run” button. okcupid_profiles &lt;- read_csv(file = &quot;data_okcupid.csv&quot;) ## Parsed with column specification: ## cols( ## age = col_double(), ## diet = col_character(), ## height = col_double(), ## pets = col_character(), ## sex = col_character(), ## status = col_character() ## ) The output indicates that you have loaded a data file and the type of data in each column. The sex column is of type col_character which indicates it contains text/letters. Most of the columns are of the type character. The age and height columns contain numbers are correspondingly indicated to be the type col_double. The label col_double indicates that a column of numbers represented in R with high precision. There are other ways of representing numbers in R but this is the type we will see/use most often. 1.9 Checking out your data There many ways of viewing the actual data you loaded. A few of these are illustrated now. 1.9.1 view(): See a spreadsheet view of your data You can inspect your data in a spreadsheet view by using the view command. Do NOT add this command to your script file – EVER. Adding it to the script can cause substantial problems. Type this command in the Console. view(okcupid_profiles) 1.9.2 print(): See you data in the Console You can inspect the first few rows of your data with the print() command. It is OK to add a print command to your script. Try the print() command below in the Console: print(okcupid_profiles) ## # A tibble: 59,946 x 6 ## age diet height pets sex status ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 22 strictly an… 75 likes dogs and l… m single ## 2 35 mostly other 70 likes dogs and l… m single ## 3 38 anything 68 has cats m availa… ## 4 23 vegetarian 71 likes cats m single ## 5 29 &lt;NA&gt; 66 likes dogs and l… m single ## 6 29 mostly anyt… 67 likes cats m single ## 7 32 strictly an… 65 likes dogs and l… f single ## 8 31 mostly anyt… 65 likes dogs and l… f single ## 9 24 strictly an… 67 likes dogs and l… f single ## 10 37 mostly anyt… 65 likes dogs and l… m single ## # … with 59,936 more rows 1.9.3 head(): Check out the first few rows of data You can inspect the first few rows of your data with the head() command. Try the command below in the Console: head(okcupid_profiles) ## # A tibble: 6 x 6 ## age diet height pets sex status ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 22 strictly any… 75 likes dogs and l… m single ## 2 35 mostly other 70 likes dogs and l… m single ## 3 38 anything 68 has cats m availa… ## 4 23 vegetarian 71 likes cats m single ## 5 29 &lt;NA&gt; 66 likes dogs and l… m single ## 6 29 mostly anyth… 67 likes cats m single You can be even more specific and indicate you only want the first three row of your data with the head() command. Try the command below in the Console: head(okcupid_profiles, 3) ## # A tibble: 3 x 6 ## age diet height pets sex status ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 22 strictly any… 75 likes dogs and l… m single ## 2 35 mostly other 70 likes dogs and l… m single ## 3 38 anything 68 has cats m availa… 1.9.4 tail(): Check out the last few rows of data You can inspect the last few rows of your data with the tail() command. Try the command below in the Console: tail(okcupid_profiles) ## # A tibble: 6 x 6 ## age diet height pets sex status ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 31 &lt;NA&gt; 62 likes dogs f single ## 2 59 &lt;NA&gt; 62 has dogs f single ## 3 24 mostly anyt… 72 likes dogs and lik… m single ## 4 42 mostly anyt… 71 &lt;NA&gt; m single ## 5 27 mostly anyt… 73 likes dogs and lik… m single ## 6 39 &lt;NA&gt; 68 likes dogs and lik… m single You can be even more specific and indicate you only want the last three row of your data with the tail() command. Try the command below in the Console: tail(okcupid_profiles, 3) ## # A tibble: 3 x 6 ## age diet height pets sex status ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 42 mostly anyt… 71 &lt;NA&gt; m single ## 2 27 mostly anyt… 73 likes dogs and lik… m single ## 3 39 &lt;NA&gt; 68 likes dogs and lik… m single 1.9.5 summary(): Quick summaries You can a short summary of your data with the summary() command. Note that we will use the summary() command in many places in the guide. The output of the summary() command changes depending on what you give it - that is put inside the brackets. You can give the summary() command many things such as data, the results of a regression analysis, etc. Try the command below in the Console. You will see that summary() give the mean and median for each of the numeric variables (age and height). summary(okcupid_profiles) ## age diet height ## Min. : 18.0 Length:59946 Min. : 1.0 ## 1st Qu.: 26.0 Class :character 1st Qu.:66.0 ## Median : 30.0 Mode :character Median :68.0 ## Mean : 32.3 Mean :68.3 ## 3rd Qu.: 37.0 3rd Qu.:71.0 ## Max. :110.0 Max. :95.0 ## NA&#39;s :3 ## pets sex status ## Length:59946 Length:59946 Length:59946 ## Class :character Class :character Class :character ## Mode :character Mode :character Mode :character ## ## ## ## 1.10 Run vs. Source with Echo vs. Source There are different ways of running commands in R. So far you have used two of these. You can enter them into the Console as we have done already. Or you can put them in your script select the text and clickk the Run button. There are four ways of running commands in your script. You can: Console: Enter commands directly Script: Select the command(s) and press the Run button. Script: Source (Without Echo) Script: Source With Echo Two of these approaches involve using the Source button, see Figure 1.5. You bring up the options for the Source button, illustrated in this figure, by clicking on the small arrow to the right of the word Source. FIGURE 1.5: Source button options 1.10.1 Run select text The Run button will run the text you highlight and present the relevant output. You have used this command a fair amount already. I strongly suggest you ONLY use the Run button when testing a command to make sure it works or to debug a script. Or to run library(tidyverse) as you start working on your script so that you get the autocomplete options. In general, you should always try to execute your R Scripts using the Source with Echo command (preceded by a Restart, see below). This ensures your script will work beginning to end for you in the future and for others that attempt to use it. Using the Run button in an ad lib basis can create output that is not reproducible. 1.10.2 Source (without Echo) Source (without Echo) is not designed for the typical analysis workflow. It is mostly helpful when you run simulations. When you run Source (without Echo) much of the output you would wish to read is suppressed. In general, avoid this option. If you use it, you often won’t see what you want to see in the output. 1.10.3 Source with Echo The Source with Echo command runs all of the contents of a script and presents the output in the R console. This is the approach you should use to running your scripts in most cases. Prior to running Source with Echo (or just Source), it’s always a good idea to restart R. This makes sure you clear the computer memory of any errors from any previous runs. So you should do the following EVERY time you run your script. Use the menu item: Session &gt; Restart R Click the down arrow beside the Source button, and click on Source With Echo This will clear potentially problematic previous stats, run the script commands, and display the output in the Console. Moving forward we will use this approach for running scripts. Once you have used Source wiht Echo once, you can just click the Source button and it will use Source with Echo automatically (without the need to use the pull down option for selecting Source with Echo). Using Restart R before you run a script, or R code in general, is a critical workflow tip. 1.11 Trying Source with Echo Put the head(), tail(), and summary() command we used previously into your script. Then save your script using using the File &gt; Save menu. You script should appear as below. # Code written on: YYYY/MM/DD # By: John Smith library(tidyverse) okcupid_profiles &lt;- read_csv(file = &quot;data_okcupid.csv&quot;) head(okcupid_profiles) tail(okcupid_profiles) summary(okcupid_profiles) Now do the following: Use the menu item: Session &gt; Restart R Click the down arrow beside the Source button, and click on Source With Echo You should see the output below: # Code written on: YYYY/MM/DD # By: John Smith library(tidyverse) okcupid_profiles &lt;- read_csv(file = &quot;data_okcupid.csv&quot;) ## Parsed with column specification: ## cols( ## age = col_double(), ## diet = col_character(), ## height = col_double(), ## pets = col_character(), ## sex = col_character(), ## status = col_character() ## ) head(okcupid_profiles) ## # A tibble: 6 x 6 ## age diet height pets sex status ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 22 strictly any… 75 likes dogs and l… m single ## 2 35 mostly other 70 likes dogs and l… m single ## 3 38 anything 68 has cats m availa… ## 4 23 vegetarian 71 likes cats m single ## 5 29 &lt;NA&gt; 66 likes dogs and l… m single ## 6 29 mostly anyth… 67 likes cats m single tail(okcupid_profiles) ## # A tibble: 6 x 6 ## age diet height pets sex status ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 31 &lt;NA&gt; 62 likes dogs f single ## 2 59 &lt;NA&gt; 62 has dogs f single ## 3 24 mostly anyt… 72 likes dogs and lik… m single ## 4 42 mostly anyt… 71 &lt;NA&gt; m single ## 5 27 mostly anyt… 73 likes dogs and lik… m single ## 6 39 &lt;NA&gt; 68 likes dogs and lik… m single summary(okcupid_profiles) ## age diet height ## Min. : 18.0 Length:59946 Min. : 1.0 ## 1st Qu.: 26.0 Class :character 1st Qu.:66.0 ## Median : 30.0 Mode :character Median :68.0 ## Mean : 32.3 Mean :68.3 ## 3rd Qu.: 37.0 3rd Qu.:71.0 ## Max. :110.0 Max. :95.0 ## NA&#39;s :3 ## pets sex status ## Length:59946 Length:59946 Length:59946 ## Class :character Class :character Class :character ## Mode :character Mode :character Mode :character ## ## ## ## Congratulations you just ran your first script! 1.12 A Few Key Points About R Sometimes you will need to send a command additional information. Moreover, that information often needs to be grouped together into a vector or a list before you can send it to the command. We’ll learn more about doing so in the future but here is a quick over view of vectors and lists to provide a foundation for future chapters. 1.12.0.1 Vector of numbers We can create a vector of only numbers using the “c” function - which you can think of as being short for “combine” (or concatenate). In the commands below we create a vector of a few even numbers called “even_numbers”. even_numbers &lt;- c(2, 4, 6, 8, 10) print(even_numbers) ## [1] 2 4 6 8 10 We can obtain the second number in the vector using the following notation: print(even_numbers[2]) ## [1] 4 1.12.0.2 Vector of characters We can also create vectors using only characters. Note that I use SHIFT RETURN after each comma to move to the next line. favourite_things &lt;- c(&quot;copper kettles&quot;, &quot;woolen mittens&quot;, &quot;brown paper packages&quot;) print(favourite_things) ## [1] &quot;copper kettles&quot; &quot;woolen mittens&quot; ## [3] &quot;brown paper packages&quot; As before, can obtain the second item in the vector using the following notation: print(favourite_things[2]) ## [1] &quot;woolen mittens&quot; 1.12.1 Lists Lists are similar to vectors in that you can create them and access items by their numeric position. Vectors must be all characters or all numbers. Lists can be a mix of characters or numbers. Most importantly items in lists can be accessed by their label. Note that I use SHIFT RETURN after each comma to move to the next line in the code below. my_list &lt;- list(last_name = &quot;Smith&quot;, first_name = &quot;John&quot;, office_number = 1913) print(my_list) ## $last_name ## [1] &quot;Smith&quot; ## ## $first_name ## [1] &quot;John&quot; ## ## $office_number ## [1] 1913 You can access an item in a list using double brackets: print(my_list[2]) ## $first_name ## [1] &quot;John&quot; You can access an item in a list by its label/name using the dollar sign: print(my_list$last_name) ## [1] &quot;Smith&quot; print(my_list$office_number) ## [1] 1913 1.13 That’s it! Congratulations! You’ve reached the end of the introduction to R. Take a break, have a cookie, and read some more about R tomorrow! "],
["handling-data-with-the-tidyverse.html", "Chapter 2 Handling Data with the Tidyverse 2.1 Required 2.2 Objective 2.3 Using the Console 2.4 Basic Tidyverse Commands 2.5 Advanced Tidyverse Commands", " Chapter 2 Handling Data with the Tidyverse 2.1 Required The following packages must be installed before starting this chapter. Required Packages tidyverse The following data files are used in this chapter: Required Data data_okcupid.csv data_experiment.csv 2.2 Objective The objective of this chapter is to familiarize you with some key commands in the tidyverse. The many commands are used in isolation of each other. In the next chapter we will use the commands in a more coordinated way as we load a data and move it from raw data to data that is ready for analysis (i.e., analytic data). You can start this project by Starting the class assignment on R Studio Cloud that corresponds to the chapter name. 2.3 Using the Console All of the commands in this chapter should be typed into the Console within R. If you see a command split over multiple lines, use SHIFT-RETURN or SHIFT-ENTER to move the next line that is part of the same command. 2.4 Basic Tidyverse Commands library(tidyverse) okcupid_profiles &lt;- read_csv(&quot;data_okcupid.csv&quot;) You can see the first few rows of the data using the print() command: print(okcupid_profiles) ## # A tibble: 59,946 x 6 ## age diet height pets sex status ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 22 strictly an… 75 likes dogs and l… m single ## 2 35 mostly other 70 likes dogs and l… m single ## 3 38 anything 68 has cats m availa… ## 4 23 vegetarian 71 likes cats m single ## 5 29 &lt;NA&gt; 66 likes dogs and l… m single ## 6 29 mostly anyt… 67 likes cats m single ## 7 32 strictly an… 65 likes dogs and l… f single ## 8 31 mostly anyt… 65 likes dogs and l… f single ## 9 24 strictly an… 67 likes dogs and l… f single ## 10 37 mostly anyt… 65 likes dogs and l… m single ## # … with 59,936 more rows But it’s also helpful just to see a list of the columns in the data with the glimpse() command: glimpse(okcupid_profiles) ## Rows: 59,946 ## Columns: 6 ## $ age &lt;dbl&gt; 22, 35, 38, 23, 29, 29, 32, 31, 24, 37, 35… ## $ diet &lt;chr&gt; &quot;strictly anything&quot;, &quot;mostly other&quot;, &quot;anyt… ## $ height &lt;dbl&gt; 75, 70, 68, 71, 66, 67, 65, 65, 67, 65, 70… ## $ pets &lt;chr&gt; &quot;likes dogs and likes cats&quot;, &quot;likes dogs a… ## $ sex &lt;chr&gt; &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f… ## $ status &lt;chr&gt; &quot;single&quot;, &quot;single&quot;, &quot;available&quot;, &quot;single&quot;,… 2.4.1 select() The select() command allows you to obtain a subset of the columns in your data. The commands below can be used to obtain the age and height columns. You can read the command as: take the okcupid_profiles data and then select the age and height columns. You can see that this prints out the data with just the age and height columns. okcupid_profiles %&gt;% select(age, height) ## # A tibble: 59,946 x 2 ## age height ## &lt;dbl&gt; &lt;dbl&gt; ## 1 22 75 ## 2 35 70 ## 3 38 68 ## 4 23 71 ## 5 29 66 ## 6 29 67 ## 7 32 65 ## 8 31 65 ## 9 24 67 ## 10 37 65 ## # … with 59,936 more rows Of course, it’s usually of little help to just print the subset of the data. It’s better to store it in a new data. In the command below we store the resulting data in a new data set called new_data. new_data &lt;- okcupid_profiles %&gt;% select(age, height) The glimpse() command shows us that only the age and height columns are in new_data. glimpse(new_data) ## Rows: 59,946 ## Columns: 2 ## $ age &lt;dbl&gt; 22, 35, 38, 23, 29, 29, 32, 31, 24, 37, 35… ## $ height &lt;dbl&gt; 75, 70, 68, 71, 66, 67, 65, 65, 67, 65, 70… In the above example we indicated the columns we wanted to retain from the okcupid_profiles data using the select() command. However, we can also indicate the columns we want to drop from okcupid_profiles using a minus sign (-) in front of the columns we specify in the select() command. new_data &lt;- okcupid_profiles %&gt;% select(-age, -height) The glimpse() command shows us that we kept all the columns except the age and height columns when we created new_data. glimpse(new_data) ## Rows: 59,946 ## Columns: 4 ## $ diet &lt;chr&gt; &quot;strictly anything&quot;, &quot;mostly other&quot;, &quot;anyt… ## $ pets &lt;chr&gt; &quot;likes dogs and likes cats&quot;, &quot;likes dogs a… ## $ sex &lt;chr&gt; &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f… ## $ status &lt;chr&gt; &quot;single&quot;, &quot;single&quot;, &quot;available&quot;, &quot;single&quot;,… 2.4.2 summarise() The summarise() command can be used to generate descriptive statistics for a specified column. You can easily calculate column descriptive statistics using the corresponding commands for mean(), sd(), min(), max(), among others. In the example below we calculate the mean for the age column. In code below mean(age, na.rm = TRUE) indicates that to R that it should calculate the mean of the age column. The na.rm indicates how missing values should be handled. The na stands for not available; in R missing values are classified as Not Available or NA. The rm stands for remove. Consequently, na.rm is asking should we remove missing values when calculating the mean. The TRUE indicates that yes, missing values should be removed when calculating the mean. The result of this calculation is placed into a variable labelled age_mean, though we could have used any label we wanted instead of age_mean. We see that the mean of the age column is, with rounding, 32.3. okcupid_profiles %&gt;% summarise(age_mean = mean(age, na.rm = TRUE)) ## # A tibble: 1 x 1 ## age_mean ## &lt;dbl&gt; ## 1 32.3 More than one calculation can occur in the same summarise() command. You can easily add the calculation for the standared deviation with the sd() command. okcupid_profiles %&gt;% summarise(age_mean = mean(age, na.rm = TRUE), age_sd = sd(age, na.rm = TRUE)) ## # A tibble: 1 x 2 ## age_mean age_sd ## &lt;dbl&gt; &lt;dbl&gt; ## 1 32.3 9.45 2.4.3 filter() The filter() command allows you to obtain a subset of the rows in your data. In the example below we create a new data set with just the males from the original data. Notice the structure of the original data below in the glimpse() output. There is a column called sex that uses m and f to indicate male and female, respectively. Also notice that there are 59946 rows in the okcupid_profiles data. glimpse(okcupid_profiles) ## Rows: 59,946 ## Columns: 6 ## $ age &lt;dbl&gt; 22, 35, 38, 23, 29, 29, 32, 31, 24, 37, 35… ## $ diet &lt;chr&gt; &quot;strictly anything&quot;, &quot;mostly other&quot;, &quot;anyt… ## $ height &lt;dbl&gt; 75, 70, 68, 71, 66, 67, 65, 65, 67, 65, 70… ## $ pets &lt;chr&gt; &quot;likes dogs and likes cats&quot;, &quot;likes dogs a… ## $ sex &lt;chr&gt; &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f… ## $ status &lt;chr&gt; &quot;single&quot;, &quot;single&quot;, &quot;available&quot;, &quot;single&quot;,… We use the the filter command to select a subset of the rows based on the contents of any column. In this case the sex column. Notice the use of the the double equals sign to indicate “equal to”. The reason a double equals sign is used here (instead of a single equals sign) it to distinguish it from the use of the single equals sign in the summarise command above. In the summarise command above, the single equal sign was used to indicate “assign to”. That is assign to age_mean the mean after it is calculated calculated. Single equals sign indicates “assign to” whereas a double equals sign indicates “is equal to”. okcupid_males &lt;- okcupid_profiles %&gt;% filter(sex == &quot;m&quot;) We use glimpse() to inspect this all male data. Notice that only the letter m is in the sex column. Also notice that there are 35829 rows in the okcupid_males data; fewer people because only the males are in this data. glimpse(okcupid_males) ## Rows: 35,829 ## Columns: 6 ## $ age &lt;dbl&gt; 22, 35, 38, 23, 29, 29, 37, 35, 28, 24, 33… ## $ diet &lt;chr&gt; &quot;strictly anything&quot;, &quot;mostly other&quot;, &quot;anyt… ## $ height &lt;dbl&gt; 75, 70, 68, 71, 66, 67, 65, 70, 72, 72, 70… ## $ pets &lt;chr&gt; &quot;likes dogs and likes cats&quot;, &quot;likes dogs a… ## $ sex &lt;chr&gt; &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m… ## $ status &lt;chr&gt; &quot;single&quot;, &quot;single&quot;, &quot;available&quot;, &quot;single&quot;,… The filter command can be commbined with the summarise command to get the descriptive statistics for males without the hassle of creating a new data. This is done using the %&gt;% “and then” operator. okcupid_profiles %&gt;% filter(sex == &quot;m&quot;) %&gt;% summarise(age_mean = mean(age, na.rm = TRUE), age_sd = sd(age, na.rm = TRUE)) ## # A tibble: 1 x 2 ## age_mean age_sd ## &lt;dbl&gt; &lt;dbl&gt; ## 1 32.0 9.03 We see that for the 35829 females the mean age is 32.0 and the standard deviation is 9.0. Likewise, we can obtain the descriptive statistics for females with only a slight modification, changing m to f in the filter command: okcupid_profiles %&gt;% filter(sex == &quot;f&quot;) %&gt;% summarise(age_mean = mean(age, na.rm = TRUE), age_sd = sd(age, na.rm = TRUE)) ## # A tibble: 1 x 2 ## age_mean age_sd ## &lt;dbl&gt; &lt;dbl&gt; ## 1 32.8 10.0 We see that for the 24117 females the mean age is 32.8 and the standard deviation is 10.0. 2.4.4 group_by() The process we used with the filter command would quickly become onerous if we had many subgroups for a column. Consequently, it’s often better to use the group() command to calculate descriptive statistics for the levels (e.g., male/female) of a variable. By telling the computer to group_by() sex the summarise command is run separately for every level of sex (i.e., m and f). okcupid_profiles %&gt;% group_by(sex) %&gt;% summarise(age_mean = mean(age, na.rm = TRUE), age_sd = sd(age, na.rm = TRUE)) ## `summarise()` ungrouping output (override with `.groups` argument) ## # A tibble: 2 x 3 ## sex age_mean age_sd ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 f 32.8 10.0 ## 2 m 32.0 9.03 Fortunately, it’s possible to use more than one grouping varible with the group_by() command. In the code below we group by sex and status (i.e., dating status). okcupid_profiles %&gt;% group_by(sex, status) %&gt;% summarise(age_mean = mean(age, na.rm = TRUE), age_sd = sd(age, na.rm = TRUE)) ## `summarise()` regrouping output by &#39;sex&#39; (override with `.groups` argument) ## # A tibble: 10 x 4 ## # Groups: sex [2] ## sex status age_mean age_sd ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 f available 32.2 8.54 ## 2 f married 33.7 8.13 ## 3 f seeing someone 28.1 6.44 ## 4 f single 33.0 10.2 ## 5 f unknown 27.8 5.91 ## 6 m available 34.8 9.40 ## 7 m married 38.7 10.1 ## 8 m seeing someone 30.8 7.06 ## 9 m single 31.9 9.04 ## 10 m unknown 40.7 8.87 The resulting output provide for age the mean and standard deviation for every combination of sex and dating status. The first five rows provide output for females at every level of dating status whereas the subsequent five rows provide output for males at every level of dating status. 2.4.5 mutate() The mutate() command can be used to calculate a new column in a data. In the example below we calculate a new column called age_centered which is the new version of the age_column where the mean of the column has been removed from every value. This is merely an example of the many different types of calculations can can perform to create a new column using mutate(). okcupid_profiles &lt;- okcupid_profiles %&gt;% mutate(age_centered = age - mean(age, na.rm = TRUE)) Notice that the glimpse() command reveals that after we use the mutate() command there is a new column called age_centered. glimpse(okcupid_profiles) ## Rows: 59,946 ## Columns: 7 ## $ age &lt;dbl&gt; 22, 35, 38, 23, 29, 29, 32, 31, 24, … ## $ diet &lt;chr&gt; &quot;strictly anything&quot;, &quot;mostly other&quot;,… ## $ height &lt;dbl&gt; 75, 70, 68, 71, 66, 67, 65, 65, 67, … ## $ pets &lt;chr&gt; &quot;likes dogs and likes cats&quot;, &quot;likes … ## $ sex &lt;chr&gt; &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;f&quot;, &quot;… ## $ status &lt;chr&gt; &quot;single&quot;, &quot;single&quot;, &quot;available&quot;, &quot;si… ## $ age_centered &lt;dbl&gt; -10.3403, 2.6597, 5.6597, -9.3403, -… 2.5 Advanced Tidyverse Commands In this advanced selection we will revisit the commands from the basic tidyverse section but use more complicated code to either select or apply an action to more than one column at a time. We will indicate the columns that we want to select or apply an action to using: starts_with(), ends_with(), contains(), matches(), or where(). The first four of these are used to indicate columns based on column names. In contrast, the last command, where(), i sued to indicate the columns we want base on the column type (numeric, character, factor, etc.). You can learn more about each of these commands by simply typing into the console a question mark followed by the function name (e.g., ?where) and then pressing return/enter. This will provide the help page for that function in Help tab in the lower right of R Studio. Note that you must have first activiated the tidyverse via library command for the help file to be accessible. We will review all five commands for indicating the columns we want in the select() selection below. Following that we will, for brevity, typically use only one of the five commands when illustrating how they work with summarise() and mutate(). We begin by loading a new data. library(tidyverse) data_exp &lt;- read_csv(&quot;data_experiment.csv&quot;) ## Parsed with column specification: ## cols( ## id = col_double(), ## sex = col_character(), ## t1_vomit = col_double(), ## t1_aggression = col_double(), ## t2_vomit = col_double(), ## t2_aggression = col_double() ## ) The glimpse() command reveals that this is a small data where every row represents one rat. The sex of the rat is recorded as well as, for each of two time points, a rating of vomiting and aggression. glimpse(data_exp) ## Rows: 6 ## Columns: 6 ## $ id &lt;dbl&gt; 1, 2, 3, 4, 5, 6 ## $ sex &lt;chr&gt; &quot;male&quot;, &quot;female&quot;, &quot;male&quot;, &quot;female&quot;,… ## $ t1_vomit &lt;dbl&gt; 3, 2, 0, 3, 2, 1 ## $ t1_aggression &lt;dbl&gt; 5, 6, 4, 7, 3, 8 ## $ t2_vomit &lt;dbl&gt; 2, 1, 1, 2, 1, 2 ## $ t2_aggression &lt;dbl&gt; 6, 7, 6, 7, 5, 8 2.5.1 select() 2.5.1.1 select() using column name 2.5.1.1.1 starts_with() starts_with() allows us to select columns based on how the column name begins. Here we put the columns that begin with “t1” into a new data called data_time1. data_time1 &lt;- data_exp %&gt;% select(starts_with(&quot;t1&quot;)) The glimpse command shows us the new data only contains the columns that begin with “t1” glimpse(data_time1) ## Rows: 6 ## Columns: 2 ## $ t1_vomit &lt;dbl&gt; 3, 2, 0, 3, 2, 1 ## $ t1_aggression &lt;dbl&gt; 5, 6, 4, 7, 3, 8 2.5.1.1.2 ends_with() ends_with() allows us to select columns based on how the column name ends. Here we put the columns that end with “aggression” into a new data set called data_aggression. data_aggression &lt;- data_exp %&gt;% select(ends_with(&quot;aggression&quot;)) glimpse(data_aggression) ## Rows: 6 ## Columns: 2 ## $ t1_aggression &lt;dbl&gt; 5, 6, 4, 7, 3, 8 ## $ t2_aggression &lt;dbl&gt; 6, 7, 6, 7, 5, 8 2.5.1.1.3 contains() contains() allows us to select columns based on the contents of the column name. Here we put the columns that have \"_\" in the name into a new data set called new_data. new_data &lt;- data_exp %&gt;% select(contains(&quot;_&quot;)) glimpse(new_data) ## Rows: 6 ## Columns: 4 ## $ t1_vomit &lt;dbl&gt; 3, 2, 0, 3, 2, 1 ## $ t1_aggression &lt;dbl&gt; 5, 6, 4, 7, 3, 8 ## $ t2_vomit &lt;dbl&gt; 2, 1, 1, 2, 1, 2 ## $ t2_aggression &lt;dbl&gt; 6, 7, 6, 7, 5, 8 2.5.1.1.4 matches() It’s also possible to use regex (regular expressiona) to select columns. Regex is a powerful way to specify search/matching requirements for text - in this case the text of column names. An explanation of regex is beyond the scope of this chapter. But the example below selects any column with and underscore in the column name followed by any character. The result is the same as the above for the contains() command. However, the matches() command is more flexible than the contains() command and can take into account substantially more complicated situations. data_matched&lt;- data_exp %&gt;% select(matches(&quot;(_.)&quot;)) You can see the columns selected using regex: glimpse(data_matched) ## Rows: 6 ## Columns: 4 ## $ t1_vomit &lt;dbl&gt; 3, 2, 0, 3, 2, 1 ## $ t1_aggression &lt;dbl&gt; 5, 6, 4, 7, 3, 8 ## $ t2_vomit &lt;dbl&gt; 2, 1, 1, 2, 1, 2 ## $ t2_aggression &lt;dbl&gt; 6, 7, 6, 7, 5, 8 You can learn about regex at RegexOne and test your regex specification at Regex101. Ideally though, as we discuss in the next chapter, you can use naming conventions that are sufficiently considered that you don’t need regex, or only rarely. The reason for this is that regex can be challenging to use. As Twitter user @ThatJenPerson noted “Regex is like tequila: use it to try to solve a problem and now you have two problems.” Nonetheless, at one or two points in the future we will use regex to solve a problem (but not tequila). 2.5.1.2 select() using column type If many cases we will want to select or perform on action on a column based on whether the column is a numeric, character, or factor column (indicated in glimpse output as dbl, chr, and fct, respectively). We will learn more about factors in a subsequent chapter. Each of these column types can be selected by using is.numeric, is.character, or is.factor, respectively, in combination with the where() command. We can select numeric columns using where() and is.numeric: data_numeric_columns &lt;- data_exp %&gt;% select(where(is.numeric)) You can see the new data contains only the numeric columns: glimpse(data_numeric_columns) ## Rows: 6 ## Columns: 5 ## $ id &lt;dbl&gt; 1, 2, 3, 4, 5, 6 ## $ t1_vomit &lt;dbl&gt; 3, 2, 0, 3, 2, 1 ## $ t1_aggression &lt;dbl&gt; 5, 6, 4, 7, 3, 8 ## $ t2_vomit &lt;dbl&gt; 2, 1, 1, 2, 1, 2 ## $ t2_aggression &lt;dbl&gt; 6, 7, 6, 7, 5, 8 We can select numeric columns using where() and is.character: data_character_columns &lt;- data_exp %&gt;% select(where(is.character)) You can see the new data contains only the character columns: glimpse(data_character_columns) ## Rows: 6 ## Columns: 1 ## $ sex &lt;chr&gt; &quot;male&quot;, &quot;female&quot;, &quot;male&quot;, &quot;female&quot;, &quot;male&quot;, &quot;… If a future chapter you will see how we can select factors using where(is.factor). 2.5.2 summarise() The summarise() command can summarise multiple columns when combined with starts_with(), ends_with(), contains(), matches(), and where(). However, to use these powerful tools for indicating columns with the summarise command we need to help of the across command (i.e., across multiple columns). If we want to obtain the mean of all the columns that start with “t1” we use the commands below. The across command requires that we indicate the columns we want via the .cols argument and the command/function we want to run on those columns via the .fns argument. In the example below, we also add na.rm = TRUE at the end; this is something we send to the mean command to let it know how we want to handle missing data. data_exp %&gt;% summarise(across(.cols = starts_with(&quot;t1&quot;), .fns = mean, na.rm = TRUE)) ## # A tibble: 1 x 2 ## t1_vomit t1_aggression ## &lt;dbl&gt; &lt;dbl&gt; ## 1 1.83 5.5 If you want to get fancy, you can also add this .names argument below which tells R to call label each output mean by the column name followed by \"_mean\". data_exp %&gt;% summarise(across(.cols = starts_with(&quot;t1&quot;), .fns = mean, na.rm = TRUE, .names = &quot;{col}_mean&quot;)) ## # A tibble: 1 x 2 ## t1_vomit_mean t1_aggression_mean ## &lt;dbl&gt; &lt;dbl&gt; ## 1 1.83 5.5 Often you want to calculate more than one statistic for each column. For example, you might want the mean, standard deviation, min, and max. These statistics can be calculated via the mean, sd, min, and max commands, respectively. However, you need to create a list with the statistics you desire. Below we create a list of the descriptive statistics we desire called desired_statistics, but you can use any name you want. This list only needs to be specified once, but we will repeat it in the examples below for clarity. desired_descriptives &lt;- list( mean = ~mean(.x, na.rm = TRUE), sd = ~sd(.x, na.rm = TRUE) ) Once you have created the list of descriptive statistics you want you can run the command below to obtain those statistics. However, as you will see the output is too wide to be helpful. data_exp %&gt;% summarise(across(.cols = starts_with(&quot;t1&quot;), .fns = desired_descriptives)) ## # A tibble: 1 x 4 ## t1_vomit_mean t1_vomit_sd t1_aggression_m… ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1.83 1.17 5.5 ## # … with 1 more variable: t1_aggression_sd &lt;dbl&gt; Consequently, we add the t() command (i.e., transpose command) to the end of the summarise request to get a more readable list of statistics: desired_descriptives &lt;- list( mean = ~mean(.x, na.rm = TRUE), sd = ~sd(.x, na.rm = TRUE) ) data_exp %&gt;% summarise(across(.cols = starts_with(&quot;t1&quot;), .fns = desired_descriptives)) %&gt;% t() ## [,1] ## t1_vomit_mean 1.833 ## t1_vomit_sd 1.169 ## t1_aggression_mean 5.500 ## t1_aggression_sd 1.871 Note that in the across command above we could also have used: ends_with(), contains(), matches(), or where(). 2.5.3 mutate() The mutate command can also be applied to multiple columns using the across() command. However, sometimes we need to embed our calculation in a custom function. Below is a custom function called make_centered. This custom function takes the values in a column an subtracts the column mean from each value in the column. This is the same task we did the mutate() command in the basic tidyverse section above. make_centered &lt;- function(values) { values_out &lt;- values - mean(values, na.rm = TRUE) return(values_out) } The glimpse() command shows us all the column names. Also notice the values in the agresssion columns.s glimpse(data_exp) ## Rows: 6 ## Columns: 6 ## $ id &lt;dbl&gt; 1, 2, 3, 4, 5, 6 ## $ sex &lt;chr&gt; &quot;male&quot;, &quot;female&quot;, &quot;male&quot;, &quot;female&quot;,… ## $ t1_vomit &lt;dbl&gt; 3, 2, 0, 3, 2, 1 ## $ t1_aggression &lt;dbl&gt; 5, 6, 4, 7, 3, 8 ## $ t2_vomit &lt;dbl&gt; 2, 1, 1, 2, 1, 2 ## $ t2_aggression &lt;dbl&gt; 6, 7, 6, 7, 5, 8 We combine the mutate() command with the across() command and our custom make_centered() command below. The command “centers” or subtracts the mean from any column that ends with “aggression”. data_exp &lt;- data_exp %&gt;% mutate(across(.cols = ends_with(&quot;aggression&quot;), .fns = make_centered)) You can see via the glimpse() output that the contents of all the columns that end with “aggression” have changed. Every value in one these columns has had the column mean subtracted from it. glimpse(data_exp) ## Rows: 6 ## Columns: 6 ## $ id &lt;dbl&gt; 1, 2, 3, 4, 5, 6 ## $ sex &lt;chr&gt; &quot;male&quot;, &quot;female&quot;, &quot;male&quot;, &quot;female&quot;,… ## $ t1_vomit &lt;dbl&gt; 3, 2, 0, 3, 2, 1 ## $ t1_aggression &lt;dbl&gt; -0.5, 0.5, -1.5, 1.5, -2.5, 2.5 ## $ t2_vomit &lt;dbl&gt; 2, 1, 1, 2, 1, 2 ## $ t2_aggression &lt;dbl&gt; -0.5, 0.5, -0.5, 0.5, -1.5, 1.5 Note that in the across command above we could also have used: starts_with(), contains(), matches(), or where(). 2.5.3.1 mutate() across rows Researchers often want to average within rows and across columns to create a new column. That is for each participant (i.e., rat in the current data) we might want to calculate an vomit rating that is the average of the two time points (that we will call vomit_avg). To average within rows (and across columns) we use the rowwise() command to inform R of our intent. After we do the necessary calculations though we have to shut off the rowwise() calculation state by using the ungroup() command. As well, when we are averaging within rows we have to use c_across() instead of across(). The command below creates a new column called vomit_avg which the average of the vomit ratings across both times. As before, we also include na.rm = TRUE so the computer drops missing values (if present) when calculating the mean. data_exp &lt;- data_exp %&gt;% rowwise() %&gt;% mutate(vomit_avg = mean( c_across(cols = ends_with(&quot;vomit&quot;)), na.rm = TRUE)) %&gt;% ungroup() You can see the new column we created with the glimpse() command: glimpse(data_exp) ## Rows: 6 ## Columns: 7 ## $ id &lt;dbl&gt; 1, 2, 3, 4, 5, 6 ## $ sex &lt;chr&gt; &quot;male&quot;, &quot;female&quot;, &quot;male&quot;, &quot;female&quot;,… ## $ t1_vomit &lt;dbl&gt; 3, 2, 0, 3, 2, 1 ## $ t1_aggression &lt;dbl&gt; -0.5, 0.5, -1.5, 1.5, -2.5, 2.5 ## $ t2_vomit &lt;dbl&gt; 2, 1, 1, 2, 1, 2 ## $ t2_aggression &lt;dbl&gt; -0.5, 0.5, -0.5, 0.5, -1.5, 1.5 ## $ vomit_avg &lt;dbl&gt; 2.5, 1.5, 0.5, 2.5, 1.5, 1.5 The print() command makes it easier to see the new column is the average of the other two. print(data_exp) ## # A tibble: 6 x 7 ## id sex t1_vomit t1_aggression t2_vomit t2_aggression ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 male 3 -0.5 2 -0.5 ## 2 2 fema… 2 0.5 1 0.5 ## 3 3 male 0 -1.5 1 -0.5 ## 4 4 fema… 3 1.5 2 0.5 ## 5 5 male 2 -2.5 1 -1.5 ## 6 6 fema… 1 2.5 2 1.5 ## # … with 1 more variable: vomit_avg &lt;dbl&gt; We can make it even easier to see by combining tidyverse commands and using only the commands colums we are interested in: data_exp %&gt;% select(contains(&quot;vomit&quot;)) %&gt;% print() ## # A tibble: 6 x 3 ## t1_vomit t2_vomit vomit_avg ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 3 2 2.5 ## 2 2 1 1.5 ## 3 0 1 0.5 ## 4 3 2 2.5 ## 5 2 1 1.5 ## 6 1 2 1.5 "],
["making-your-data-ready-for-analysis.html", "Chapter 3 Making your data ready for analysis 3.1 Required Packages 3.2 Objective 3.3 Context 3.4 Begin with the end in mind 3.5 Data collection and entry 3.6 Raw data 3.7 Loading raw data 3.8 Initial inspection 3.9 Handling categorical variables 3.10 Seeing your data 3.11 Dealing with reverse key items 3.12 Creating the scale score 3.13 Creatinig analytic data from raw data 3.14 Wait: I need alpha! 3.15 Wait: I need item correlations and descriptive statistics 3.16 Using R the old way or the new way (the tidyverse way)", " Chapter 3 Making your data ready for analysis 3.1 Required Packages This chapter requires the following packages are installed: Required Packages apaTables janitor psych tidyverse Important Note: that you should NOT use library(psych) at any point. There are major conflict between the psych package and the tidyverse. We will access the psych package command by preceding each command with psych:: instead of using library(psych). 3.2 Objective 3.3 Context Due to a number of high profile failure to replicate study results (Nosek 2015) it’s become increasingly clear that there is a general crisis of confidence in many areas of science (Baker 2016). Statistical (and other) explanations have been offered (Simmons, Nelson, and Simonsohn 2011) for why it’s hard to replicate results across different sets of data. However, scientists are also finding it challenging to recreate the numbers in their papers using their own data. Indeed, the editor of Molecular Brain asked authors to submit the data used to create the numbers in published papers and found that the wrong data was submitted for 40 out of 41 papers (Miyakawa 2020). Consequently, some researchers have suggested that it is critical to distinguish between replication and reproducibility (Patil P. 2019). Replication refers to trying to obtain the same result from a different data sets. Reproducibility refers to trying to obtain the same results from the same data set. It may seem that reproducibility should be given - but it’s not. Correspondingly, there a trend is for journals and authors to adopt Transparency and Openness Promotion (TOP) guidelines. These guidelines involve such things as making your materials, data, code, and analysis scripts available on public repositories so anyone can check your data. A new open science journal rating system has even emerged called the TOP Factor. The idea is not that open science articles are more trustworthy that other types of articles – the idea is that trust doesn’t play a role. Anyone can inspect the data using the scripts and data provided by authors. It’s really just the same as making your science available for auditing the way financial records can be audited. The problems reported at Molecular Brain (doubtless is common to many journals) are avoided with open science - because the data and scripts needed to reproduce the numbers in the articles are uploaded prior to publication. The TOP open science guidelines have made an impact and some newer journals, such as Meta Psycchology, have fully embraced open science. Figure 3.1 shows the header from an article in Meta Psychology that clearly delineates the open science attributes of the article. Take note that the header even specifies who checked that the analyses in the article were reproducible from the scripts and data made publicly available by the authors. FIGURE 3.1: Open science in an article header In Canada, the majority of university research is funded by the Federal Government’s Tri-Agency (i.e., NSERC, SSHRC, CIHR). The agency has a new draft Data Management Policy in which they state that “The agencies believe that research data collected with the use of public funds belong, to the fullest extent possible, in the public domain and available for reuse by others.” This perspective of the funding agency differs from that of some researchers who incorrectly believe “they own their data”. In Canada at least, the government makes it clear that tax payers fund the research so the data is public property. Additionally the Tri-Agency Data Management policy clearly indicates the responsibilities of funded researchers: \"Responsibilities of researchers include: incorporating data management best practices into their research; developing data management plans to guide the responsible collection, formatting, preservation and sharing of their data throughout the entire lifecycle of a research project and beyond; following the requirements of applicable institutional and/or funding agency policies and professional or disciplinary standards; acknowledging and citing datasets that contribute to their research; and staying abreast of standards and expectations of their disciplinary community.\" As a result of this perspective on data, it’s important that you think about structuring your data for reuse by yourself and others before you collect it. Toward this end, you will see documentation of your data file via data codebooks is critical. 3.4 Begin with the end in mind In this chapter we will walk you though the steps from data collection, data entry, loading raw data, and the creation of analytic data via preprocessing scripts. These steps are outlined in Figure 3.2. This figure makes a clear distinction between raw data and analytic data. Raw data refers to the data as you entered it into a spreadsheet or received it from survey software. Analytic data the data the has been structured and processed so that it is ready for analyis. This pre-processing could include such things as identifying categorical variables to the computer, combining multiple items measuring the same thing into scale scale scores, among other tasks. It’s critial that you don’t think of analysis of your results as being completely removed from the data collection and data entry choices you make. Poor choices at the data collection and data entry stage can make your life substantially more complicated when it comes time to write the preprocessing script that will convert your raw data to analytic data. The mantra of this chapter is begin with the end in mind. FIGURE 3.2: Data science pipeline by Roger Peng. It’s difficult to being with the end in mind when you haven’t read later chapters. So here we will be provide you with some general thoughts around different approaches to structuring data files and the naming conventions you use when creating those data files. 3.4.1 tidy data: Comparing wide vs long formats When conducting many types of analyses it is necessary to have data in a format called tidy data (Wickham 2014). tidy data as defined by Hadley involves (among other requirements) that: Each variable forms a column. Each observation forms a row. The tidy data format can be initially challenging for some researchers to understand because it is based on thinking about, and structuring data, in terms of observations/measurements instead of participants. In this section we will describe common approaches to entering animal and human particpant data and how they can be done keeping the tidy data requirement in mind. It’s not essential that data be entered in a tidy data format but it is essential that you enter data in way that makes it easy to later convert data to a tidy data format. When dealing with animal or human participant data it’s common to enter data into a spreadsheet. Each row of the spreadsheet is typically used to represent a single participant and each column of the spreadshet is used to represent a variable. Between participant data. Consider Table 3.1 which illustrates between particpant data for six human particpants running 5 kilometers The first column is id, which indicates there are six unique participants and provides and identification number for each of them. The id is the varible and there is one observation per row - so the id column conforms to tidy data specification. The second column is sex, which is a varible, and there is one observation per for row, so sex also conforms to the tidy data specification. Finally, there is a last column five_km_time which is a variable with one observation per row – also conforming to tidy data specification. Thus, single occasion between subject data like this conforms to the tidy data specification. There is usually nothing you need to do to convert between participant data (or cross-sectional data) to be in a tidy data format. TABLE 3.1: Between participant data entered one row per participant id sex elapsedtime 1 male 40 2 female 35 3 male 38 4 female 33 5 male 42 6 female 36 Within participant data. Consider Table 3.2 which illustrates within particpant data for six human particpants running 5 kilometers - but on three different occasions. The first column is id, which indicates there are six unique participants and provides and identification number for each of them. The id is the varible and there is one observation per row - so the id column conforms to tidy data specification. The second column is sex, which is a varible, and there is one observation per for row, so sex also conforms to the tidy data specification. Next, there are three different columns (march, may, july) representing the levels of a single variable. That is the within subject variable is occasion and the levels of that variable are march, june, and july. The march column contains the times for participants in March. The may column contians the times for particpants in May. The july column contains the times for participants in July, These three columns are not in a tidy data format. TABLE 3.2: Within participant data entered one row per participant id sex march may july 1 male 40 37 35 2 female 35 32 30 3 male 38 35 33 4 female 33 30 28 5 male 42 39 37 6 female 36 33 31 TABLE 3.3: A tidy data version of the within participant data id sex occasion elapsedtime 1 male march 40 1 male may 37 1 male july 35 2 female march 35 2 female may 32 2 female july 30 3 male march 38 3 male may 35 3 male july 33 4 female march 33 4 female may 30 4 female july 28 5 male march 42 5 male may 39 5 male july 37 6 female march 36 6 female may 33 6 female july 31 The problem with the format of the data in Table 3.2 is that march, may, and july are levels of single variable, occasion, that is not represented in the data. Nowhere in the Table 3.2 can you see the variable occasion. This single variable is presented over three columns - a very confusing situation. Moreover, due to the way the columns are labelled it’s not clear what is being measured. Nowhere in Table 3.2 can you see the variable time. Thus with the format used in 3.2 you don’t know what the predictor (occassion) is nor do you know the dependent varible (time). Thus, a major problem with entering data in this format is that there are hidden variables in the data and you need insider knowledge to know the columns represent. That said, this is not necessarily a terrible way to enter your data as long as you have all of this missing information documented in a data code book. Disadvantages one row per participant Advantages one row per participant 1) Predictor variable (occassion) is hidden and spread over multiple columns 1) Easy to enter this way 2) Unclear that each month is a level of the predictor variable occasion 3) Dependent variable (elapsedtime) is not indicated 4) Unclear that elapsedtime is the measurement in each month column Fortunately, the problems with Table 3.2 can be largely resolved by converting the data to the a tidy data format. This can be done with the pivot_long() command that we will learn about later in the chapter. Thus, we can enter the data in the easy to enter format of Table 3.2 but then later convert it to a tidy data format. After this conversion the data will be appear as in Table 3.3. For elapsedtime variable this data is now in the tidy data format. Each row corresponds to a single elapsedtime observed. Each column corresponds to a single variable. Somewhat problematically, however, sex if repeated three times for each person (i.e., over the three rows) - and this can be confusing. However, if the focus in on analyzing elapsed time this tidy data format makes sense. Why did we walk you through this technical treatment of structuring data within the computer at this point in time? So that you pay attention to the advice the follows. You can see at this point that you may well need to restructure your data for certain analyses. The ability to do so quickly and easily depends upon you following the advice in the rest of this chapter around the naming conventions for variables and other aspects of your analyses. You can imagine the challenges for converting the data in Figure 3.2 to the data in Figure 3.3 by hand. You want to be able to automate that process and others - which is made substantially easier if you following the forthcoming advice about naming conventions in the tidyverse. 3.5 Data collection and entry 3.5.1 Question with numerical answers 3.5.2 Likert-type items relate back to select function in previous chapter 3.5.3 Multi-item scales 3.5.4 Questions with categorical answers Avoid categorical if not really categorical Avoid numerical representation of categorical variables 3.5.5 Levels of an independent varible 3.5.6 Levels of a single within participant variable 3.5.7 Levels of multiple within participant variables relate back to select function in previous chapter Do this one first when generating above advice Surveys - use meaningful names - use meaningful names for subsets -sample size analysis -unfeasible article by lakens data are collected in different ways data collected by programs in the lab that require lab measurements paper and entering later paper surveys and entering later website surveys a mix of all of the above each trial is a row - multiple rows per person… Distinguish between entering data and not. But also think about what’s not confusing… talk about wide not showing DV or IV just levels of IV if you’re writing a cognitive program or making a survey think about the variable names think about how the data is outputted. If you have entirely within person data then tidy is the obvious choice If you have entirely between then wide makes sense If you have a mix - it’s more difficult. Different research area. Think about the problems. For example, a good data code book is essential if you have wide with repeated measures variables because there is no way to tell what the IV or DV is by inspecting the data. TIDYVERSE NAMING CONVENTION ARE IMPORTANT BECAUSE IN SOME CASES THEY ARE REQUIRED for the SCRIPTS to work. If you haven’t following the naming conventions you may be making your life quite difficult. Think about - missing data - column names - representation of categorical variables in the data set computer/web collection 3.6 Raw data We begin by examining the data as originally entered into a spreadsheet. In Figure 3.3 you see a screen shot of the initial raw data as a researcher might receive it. Take careful note of the numerous -999 values used to indicate missing values. As part of creating the analytic data that we will analyze we need to indicate to the computer that the -999 are not data but codes to represent missing values. FIGURE 3.3: Raw data for item scoring 3.7 Loading raw data I suggest you begin every R Studio task in the following way: R Studio in the Cloud 1. Create a new Project using the web interface 2. Upload your data files in using the upload button in the Files pane R Studio on Your Computer 1. Create a folder on your computer for the analysis 2. Place your data files in that folder 3. Use the menu item File &gt; New Project… to start the project 4. On the window that appears select “Existing Directory” 5. On the next screen, press the “Browse” button and find/select the folder with your data 6. Press the Create Project Button Regardless of whether your are working from the cloud or locally you should now have an R Studio project with your data files in it. Using Projects. Class note: You don’t’ need to do either of these approach. You will just “Start” each assignment in the class workspace on R Studio Cloud\". Create an R Studio project for this activity Create a new script in your project and save it quite library(tidyverse) library(janitor) my_missing_value_codes &lt;- c(&quot;-999&quot;, &quot;&quot;, &quot;NA&quot;) raw_data &lt;- read_csv(file = &quot;data_item_scoring.csv&quot;, na = my_missing_value_codes) ## Parsed with column specification: ## cols( ## id = col_double(), ## age = col_double(), ## sex = col_character(), ## SE1 = col_double(), ## SE2 = col_double(), ## SE3 = col_double(), ## SE4 = col_double(), ## SE5 = col_double(), ## SE6 = col_double(), ## SE7 = col_double(), ## SE8 = col_double(), ## SE9 = col_double(), ## SE10 = col_double() ## ) 3.8 Initial inspection We use glimpse to do an initial inspection of the column names in this data set. All of the column name conform to tidyverse style guidelines so we do not need to run the clean_name() function from the janitor package glimpse(raw_data) ## Rows: 300 ## Columns: 13 ## $ id &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 1… ## $ age &lt;dbl&gt; 23, 22, 18, 23, 22, 17, 23, 22, 17, 21, 20, … ## $ sex &lt;chr&gt; &quot;male&quot;, &quot;female&quot;, &quot;male&quot;, &quot;female&quot;, &quot;male&quot;, … ## $ SE1 &lt;dbl&gt; 3, 4, 4, 3, 3, 3, 3, 4, 4, 4, 3, 4, NA, NA, … ## $ SE2 &lt;dbl&gt; 2, 3, 3, 2, 2, 3, 2, 3, 3, 3, 2, 2, NA, 3, 2… ## $ SE3 &lt;dbl&gt; 4, 4, 4, 3, 4, 4, NA, 4, 4, 3, 4, 4, 4, NA, … ## $ SE4 &lt;dbl&gt; 3, 4, 4, 3, 4, 4, 4, 4, 3, 4, NA, 4, 3, 3, 4… ## $ SE5 &lt;dbl&gt; 4, 4, 4, 4, 4, NA, NA, 4, 4, 4, 3, 4, 4, 3, … ## $ SE6 &lt;dbl&gt; 3, 5, 4, 3, 3, 3, 3, 5, 3, 3, 3, 4, 4, 3, 3,… ## $ SE7 &lt;dbl&gt; 1, 1, 1, NA, 1, 1, 2, 1, 2, 2, 3, 1, 3, 2, 1… ## $ SE8 &lt;dbl&gt; 3, NA, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 3… ## $ SE9 &lt;dbl&gt; NA, 5, 5, 4, 4, 4, 4, 5, NA, 4, NA, 5, 4, 4,… ## $ SE10 &lt;dbl&gt; 5, NA, 5, 4, 5, 4, 4, 5, 5, 5, 4, NA, 4, 5, … view(raw_data) See Figure 3.4 FIGURE 3.4: Missing values now NA 3.9 Handling categorical variables # Turn all columns that are of type character into factors raw_data &lt;- raw_data %&gt;% mutate(across(.cols = where(is.character), .fns = as.factor)) We can see there was only one column that changes, but if there had been many columns that were characters they all would have changed. glimpse(raw_data) ## Rows: 300 ## Columns: 13 ## $ id &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 1… ## $ age &lt;dbl&gt; 23, 22, 18, 23, 22, 17, 23, 22, 17, 21, 20, … ## $ sex &lt;fct&gt; male, female, male, female, male, female, ma… ## $ SE1 &lt;dbl&gt; 3, 4, 4, 3, 3, 3, 3, 4, 4, 4, 3, 4, NA, NA, … ## $ SE2 &lt;dbl&gt; 2, 3, 3, 2, 2, 3, 2, 3, 3, 3, 2, 2, NA, 3, 2… ## $ SE3 &lt;dbl&gt; 4, 4, 4, 3, 4, 4, NA, 4, 4, 3, 4, 4, 4, NA, … ## $ SE4 &lt;dbl&gt; 3, 4, 4, 3, 4, 4, 4, 4, 3, 4, NA, 4, 3, 3, 4… ## $ SE5 &lt;dbl&gt; 4, 4, 4, 4, 4, NA, NA, 4, 4, 4, 3, 4, 4, 3, … ## $ SE6 &lt;dbl&gt; 3, 5, 4, 3, 3, 3, 3, 5, 3, 3, 3, 4, 4, 3, 3,… ## $ SE7 &lt;dbl&gt; 1, 1, 1, NA, 1, 1, 2, 1, 2, 2, 3, 1, 3, 2, 1… ## $ SE8 &lt;dbl&gt; 3, NA, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 3… ## $ SE9 &lt;dbl&gt; NA, 5, 5, 4, 4, 4, 4, 5, NA, 4, NA, 5, 4, 4,… ## $ SE10 &lt;dbl&gt; 5, NA, 5, 4, 5, 4, 4, 5, 5, 5, 4, NA, 4, 5, … It’s often helpful to has id as a factor rather than a number so we add and extra command that changes this value: raw_data &lt;-raw_data %&gt;% mutate(id = as.factor(id)) Now it looks like our data is ready for the creation of scale scores: glimpse(raw_data) ## Rows: 300 ## Columns: 13 ## $ id &lt;fct&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 1… ## $ age &lt;dbl&gt; 23, 22, 18, 23, 22, 17, 23, 22, 17, 21, 20, … ## $ sex &lt;fct&gt; male, female, male, female, male, female, ma… ## $ SE1 &lt;dbl&gt; 3, 4, 4, 3, 3, 3, 3, 4, 4, 4, 3, 4, NA, NA, … ## $ SE2 &lt;dbl&gt; 2, 3, 3, 2, 2, 3, 2, 3, 3, 3, 2, 2, NA, 3, 2… ## $ SE3 &lt;dbl&gt; 4, 4, 4, 3, 4, 4, NA, 4, 4, 3, 4, 4, 4, NA, … ## $ SE4 &lt;dbl&gt; 3, 4, 4, 3, 4, 4, 4, 4, 3, 4, NA, 4, 3, 3, 4… ## $ SE5 &lt;dbl&gt; 4, 4, 4, 4, 4, NA, NA, 4, 4, 4, 3, 4, 4, 3, … ## $ SE6 &lt;dbl&gt; 3, 5, 4, 3, 3, 3, 3, 5, 3, 3, 3, 4, 4, 3, 3,… ## $ SE7 &lt;dbl&gt; 1, 1, 1, NA, 1, 1, 2, 1, 2, 2, 3, 1, 3, 2, 1… ## $ SE8 &lt;dbl&gt; 3, NA, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 3… ## $ SE9 &lt;dbl&gt; NA, 5, 5, 4, 4, 4, 4, 5, NA, 4, NA, 5, 4, 4,… ## $ SE10 &lt;dbl&gt; 5, NA, 5, 4, 5, 4, 4, 5, 5, 5, 4, NA, 4, 5, … 3.10 Seeing your data See the first six rows of the data with the head command below. If you wanted to see all of the data you would use View(raw_data). The NA values in the output indicate missing values (NA = Not Available). head(raw_data) ## # A tibble: 6 x 13 ## id age sex SE1 SE2 SE3 SE4 SE5 SE6 ## &lt;fct&gt; &lt;dbl&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 23 male 3 2 4 3 4 3 ## 2 2 22 female 4 3 4 4 4 5 ## 3 3 18 male 4 3 4 4 4 4 ## 4 4 23 female 3 2 3 3 4 3 ## 5 5 22 male 3 2 4 4 4 3 ## 6 6 17 female 3 3 4 4 NA 3 ## # … with 4 more variables: SE7 &lt;dbl&gt;, SE8 &lt;dbl&gt;, SE9 &lt;dbl&gt;, ## # SE10 &lt;dbl&gt; 3.11 Dealing with reverse key items Our first step is dealing with reverse key items. The way you deal with these items depends on how you scored them. Imagine you had a 5-point scale. You could have scored the scale with the values 1, 2, 3, 4, and 5. Alternatively, you could have scored the scale with the values 0, 1, 2, 3, and 4. In this example, we scored the data using the 1 to 5 system. So we’ll use that. Later I’ll show you how to deal with the other scoring system (0 to 4). 3.11.1 Scoring items where the ratings scale starts with 1 We need to take items that were reversed-key when the participant wrote them and recode those responses. We do that with using the mutate command from the dplyr package. In this data file the only reverse-key item was SE7 (we known this from when we created the survey). We use the command below to reverse key an item with response options ranging from 1 to 5. So we use 6 in the command (i.e., one higher than 5). raw_data &lt;-raw_data %&gt;% mutate(SE7c = 6 - SE7) The command above creates a new column in raw_data called SE7c that has the reverse-keyed values for SE7 in it. You can see the new SE7c column using command below that displays the first six rows of the data. The SE7c column is at the far right of the data displayed. glimpse(raw_data) ## Rows: 300 ## Columns: 14 ## $ id &lt;fct&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 1… ## $ age &lt;dbl&gt; 23, 22, 18, 23, 22, 17, 23, 22, 17, 21, 20, … ## $ sex &lt;fct&gt; male, female, male, female, male, female, ma… ## $ SE1 &lt;dbl&gt; 3, 4, 4, 3, 3, 3, 3, 4, 4, 4, 3, 4, NA, NA, … ## $ SE2 &lt;dbl&gt; 2, 3, 3, 2, 2, 3, 2, 3, 3, 3, 2, 2, NA, 3, 2… ## $ SE3 &lt;dbl&gt; 4, 4, 4, 3, 4, 4, NA, 4, 4, 3, 4, 4, 4, NA, … ## $ SE4 &lt;dbl&gt; 3, 4, 4, 3, 4, 4, 4, 4, 3, 4, NA, 4, 3, 3, 4… ## $ SE5 &lt;dbl&gt; 4, 4, 4, 4, 4, NA, NA, 4, 4, 4, 3, 4, 4, 3, … ## $ SE6 &lt;dbl&gt; 3, 5, 4, 3, 3, 3, 3, 5, 3, 3, 3, 4, 4, 3, 3,… ## $ SE7 &lt;dbl&gt; 1, 1, 1, NA, 1, 1, 2, 1, 2, 2, 3, 1, 3, 2, 1… ## $ SE8 &lt;dbl&gt; 3, NA, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 3… ## $ SE9 &lt;dbl&gt; NA, 5, 5, 4, 4, 4, 4, 5, NA, 4, NA, 5, 4, 4,… ## $ SE10 &lt;dbl&gt; 5, NA, 5, 4, 5, 4, 4, 5, 5, 5, 4, NA, 4, 5, … ## $ SE7c &lt;dbl&gt; 5, 5, 5, NA, 5, 5, 4, 5, 4, 4, 3, 5, 3, 4, 5… We have reverse keyed one item. So now when we create our scale we will use item SE7c (the c stands for correctly coded) instead of the original item SE7. That is, we will use items SE1, SE2, SE3, SE4, SE5, SE6, SE7c, SE8, SE9, and SE10 to form the scale. Note for a box multiple items what it looks like Note FOR A BOX . If you had used response options numbered 0 to 4 for each item you would use the command below instead. Note that we use 4 in the command this time instead of a value one higher. raw_data &lt;- mutate(raw_data, SE7c = 4 - SE7) 3.12 Creating the scale score raw_data &lt;- raw_data %&gt;% rowwise() %&gt;% mutate(self_esteem = mean(c(SE1, SE2, SE3, SE4, SE5, SE6, SE7c, SE8, SE9, SE10), na.rm = TRUE)) %&gt;% ungroup() When you see ungroup() in this context you can think of it as “turn off rowwise”. We can see our data now has the self esteem column: glimpse(raw_data) ## Rows: 300 ## Columns: 15 ## $ id &lt;fct&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12… ## $ age &lt;dbl&gt; 23, 22, 18, 23, 22, 17, 23, 22, 17, 2… ## $ sex &lt;fct&gt; male, female, male, female, male, fem… ## $ SE1 &lt;dbl&gt; 3, 4, 4, 3, 3, 3, 3, 4, 4, 4, 3, 4, N… ## $ SE2 &lt;dbl&gt; 2, 3, 3, 2, 2, 3, 2, 3, 3, 3, 2, 2, N… ## $ SE3 &lt;dbl&gt; 4, 4, 4, 3, 4, 4, NA, 4, 4, 3, 4, 4, … ## $ SE4 &lt;dbl&gt; 3, 4, 4, 3, 4, 4, 4, 4, 3, 4, NA, 4, … ## $ SE5 &lt;dbl&gt; 4, 4, 4, 4, 4, NA, NA, 4, 4, 4, 3, 4,… ## $ SE6 &lt;dbl&gt; 3, 5, 4, 3, 3, 3, 3, 5, 3, 3, 3, 4, 4… ## $ SE7 &lt;dbl&gt; 1, 1, 1, NA, 1, 1, 2, 1, 2, 2, 3, 1, … ## $ SE8 &lt;dbl&gt; 3, NA, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, … ## $ SE9 &lt;dbl&gt; NA, 5, 5, 4, 4, 4, 4, 5, NA, 4, NA, 5… ## $ SE10 &lt;dbl&gt; 5, NA, 5, 4, 5, 4, 4, 5, 5, 5, 4, NA,… ## $ SE7c &lt;dbl&gt; 5, 5, 5, NA, 5, 5, 4, 5, 4, 4, 3, 5, … ## $ self_esteem &lt;dbl&gt; 3.556, 4.250, 4.100, 3.222, 3.700, 3.… (Alternative code: removing ITEM 7 and using beings with: show full example) Think about this when creating names for your column 3.13 Creatinig analytic data from raw data Select only the columns you will use in your analysis: analytic_data &lt;- raw_data %&gt;% select(id, age, sex, self_esteem) We can see our new data set has only these columns of interest: glimpse(analytic_data) ## Rows: 300 ## Columns: 4 ## $ id &lt;fct&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12… ## $ age &lt;dbl&gt; 23, 22, 18, 23, 22, 17, 23, 22, 17, 2… ## $ sex &lt;fct&gt; male, female, male, female, male, fem… ## $ self_esteem &lt;dbl&gt; 3.556, 4.250, 4.100, 3.222, 3.700, 3.… 3.14 Wait: I need alpha! We return to the raw_data file that has the original item data to obtain Cronbach’s alpha which is labeled “raw alpha” in the output. self_esteem_item_analysis &lt;- raw_data %&gt;% select(SE1, SE2, SE3, SE4, SE5, SE6, SE7c, SE8, SE9, SE10) %&gt;% psych::alpha() print(self_esteem_item_analysis$total) ## raw_alpha std.alpha G6(smc) average_r S/N ase mean ## 0.8278 0.8333 0.8276 0.3333 4.999 0.0143 3.656 ## sd median_r ## 0.3392 0.3277 # To see the full item analysis use: # print(self_esteem_item_analysis) 3.15 Wait: I need item correlations and descriptive statistics SE_items &lt;- raw_data %&gt;% select(starts_with(&quot;SE&quot;, ignore.case = FALSE)) psych::describe(SE_items) ## vars n mean sd median ## SE1 1 276 3.39 0.54 3 ## SE2 2 272 2.35 0.48 2 ## SE3 3 269 3.96 0.37 4 ## SE4 4 285 3.54 0.50 4 ## SE5 5 265 3.78 0.47 4 ## SE6 6 275 3.34 0.51 3 ## SE7 7 273 1.51 0.61 1 ## SE8 8 272 2.84 0.37 3 ## SE9 9 265 4.29 0.70 4 ## SE10 10 276 4.57 0.61 5 ## SE7c 11 273 4.49 0.61 5 When you run the cor command you have to indicate how the it will handle missing the data. The options are below. You can learn more about what each one of these options means by typing: ?cor into the Console, this will bring up the help page for the cor command. Missing data options for cor everything all.obs complete.obs na.or.complete pairwise.complete.obs SE_items %&gt;% cor(use = &quot;pairwise.complete.obs&quot;) %&gt;% round(2) ## SE1 SE2 SE3 SE4 SE5 SE6 SE7 SE8 SE9 ## SE1 1.00 0.31 0.20 0.34 0.34 0.33 -0.32 0.28 0.38 ## SE2 0.31 1.00 0.24 0.22 0.31 0.32 -0.29 0.29 0.36 ## SE3 0.20 0.24 1.00 0.28 0.30 0.23 -0.43 0.38 0.35 ## SE4 0.34 0.22 0.28 1.00 0.29 0.34 -0.37 0.32 0.32 ## SE5 0.34 0.31 0.30 0.29 1.00 0.39 -0.41 0.41 0.43 ## SE6 0.33 0.32 0.23 0.34 0.39 1.00 -0.32 0.24 0.34 ## SE7 -0.32 -0.29 -0.43 -0.37 -0.41 -0.32 1.00 -0.44 -0.42 ## SE8 0.28 0.29 0.38 0.32 0.41 0.24 -0.44 1.00 0.51 ## SE9 0.38 0.36 0.35 0.32 0.43 0.34 -0.42 0.51 1.00 ## SE10 0.31 0.34 0.28 0.19 0.40 0.25 -0.39 0.35 0.36 ## SE7c 0.32 0.29 0.43 0.37 0.41 0.32 -1.00 0.44 0.42 ## SE10 SE7c ## SE1 0.31 0.32 ## SE2 0.34 0.29 ## SE3 0.28 0.43 ## SE4 0.19 0.37 ## SE5 0.40 0.41 ## SE6 0.25 0.32 ## SE7 -0.39 -1.00 ## SE8 0.35 0.44 ## SE9 0.36 0.42 ## SE10 1.00 0.39 ## SE7c 0.39 1.00 3.16 Using R the old way or the new way (the tidyverse way) Previously we noted that there is an older way of using R (base R) and the new way of using R (the tidyverse) that we will use. Sometimes students have problems with their code when they mix and match these approaches using a bit of both. We will be using the tidyverse approach to using R but on the internet you will often see sample code that uses the older base R approach. A bit of background knowledge is helpful for understanding why we do things one way (e.g., read_csv with the tidyverse) instead of another (e.g., read.csv with base R). 3.16.0.1 Tibbles vs Data Frames: Why use read_csv instead of read.csv When you load data into R it is typically represented in one of two formats inside the computer - depending on the command you used. The original format for representing a data set in R is the data frame. You will see this term used frequently when you read about R. When you load data using read.csv your data is loaded into a data frame in the computer. That is your data is represented in the memory of the computer in particular format and structure called a data frame. 3.16.0.2 read.csv puts data into a data frame my_dataframe &lt;- read.csv(file = &quot;data_okcupid.csv&quot;) Notice that when you print a data frame it does NOT show you the number of rows or columns above the data like our example did with the okcupid_profiles data. It also list ALL of your data rather than just the first few rows. As a result in the output below I show only the first 10 rows of the output - because all the rows are printed in your Console (too much to show here). print(my_dataframe) ## age diet height pets ## 1 22 strictly anything 75 likes dogs and likes cats ## 2 35 mostly other 70 likes dogs and likes cats ## 3 38 anything 68 has cats ## 4 23 vegetarian 71 likes cats ## 5 29 &lt;NA&gt; 66 likes dogs and likes cats ## 6 29 mostly anything 67 likes cats ## 7 32 strictly anything 65 likes dogs and likes cats ## 8 31 mostly anything 65 likes dogs and likes cats ## 9 24 strictly anything 67 likes dogs and likes cats ## 10 37 mostly anything 65 likes dogs and likes cats ## sex status ## 1 m single ## 2 m single ## 3 m available ## 4 m single ## 5 m single ## 6 m single ## 7 f single ## 8 f single ## 9 f single ## 10 m single 3.16.0.3 read_csv puts data into a tibble When you use the read_csv command the data you load is stored in the computer as a tibble. The tibble is modern version of the data frame. Notice that when you print a tibble it DOES show you the number of rows and columns. As well, the tibble only provides the first few rows of output so it doesn’t fill your screen. my_tibble &lt;- read_csv(file = &quot;data_okcupid.csv&quot;) ## Parsed with column specification: ## cols( ## age = col_double(), ## diet = col_character(), ## height = col_double(), ## pets = col_character(), ## sex = col_character(), ## status = col_character() ## ) print(my_tibble) ## # A tibble: 59,946 x 6 ## age diet height pets sex status ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 22 strictly an… 75 likes dogs and l… m single ## 2 35 mostly other 70 likes dogs and l… m single ## 3 38 anything 68 has cats m availa… ## 4 23 vegetarian 71 likes cats m single ## 5 29 &lt;NA&gt; 66 likes dogs and l… m single ## 6 29 mostly anyt… 67 likes cats m single ## 7 32 strictly an… 65 likes dogs and l… f single ## 8 31 mostly anyt… 65 likes dogs and l… f single ## 9 24 strictly an… 67 likes dogs and l… f single ## 10 37 mostly anyt… 65 likes dogs and l… m single ## # … with 59,936 more rows 3.16.0.4 Deeper differences between data frames and tibbles In short you should always use tibbles (i.e., use read_csv) - they are simply enhanced data frames (i.e., the new version of the data frame). The differences between data frames and tibbles run deeper than the superficial output provided here. On some rare occasions an old package or command may not work with a tibble so you need to make it a data frame. You can do so with the commands below: 3.16.0.5 Converting a tibble into a data frame This command creates a new data set called new_data_frame (use any name you want) from the tibble data. new_dataframe &lt;- as.data.frame(my_tibble) References "],
["more-to-say.html", "A More to Say", " A More to Say Yeah! I have finished my book, but I have more to say about some topics. Let me explain them in this appendix. To know more about bookdown, see https://bookdown.org. "],
["references.html", "References", " References "]
]
