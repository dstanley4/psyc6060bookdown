# Data Management with the Tidyverse

```{r, include=FALSE}
library(tidyverse)
```

## Required Packages

This chapter requires the following packages are installed:

| Required Packages |
|-------------------|
|tidyverse          |


## Basic Tidyverse Commands

```{r, eval = FALSE}
library(tidyverse)
okcupid_profiles <- read_csv("data_okcupid.csv")
```

```{r, include = FALSE}
library(tidyverse)
okcupid_profiles <- read_csv("data_okcupid.csv")
```

You can see the first few rows of the data set using the print() command:

```{r}
print(okcupid_profiles)
```

But it's also helpful just to see a list of the columns in the data set with the glimpse() command:

```{r}
glimpse(okcupid_profiles)
```

### select()

The select() command allows you to obtain a subset of the columns in your data. The command below obtains can be used to obtain the age and height columns. You can read the command as: take the okcupid_profiles data and then select the age and height columns. You can see that this prints out the data with just the age and height columns.

```{r}
okcupid_profiles %>% select(age, height)
```


Of course, it's usually of little help to just print the subset of the data. It's better to store it in a new data set. In the command below we store the resulting data set in a data set called new_data.

```{r}
new_data <- okcupid_profiles %>% select(age, height)
```

The glimpse() command shows us that only the age and height columns are in new_data.

```{r}
glimpse(new_data)
```

In the above example we indicated the columns we wanted to retain from the okcupid_profiles data in the select() command. However, we also indicate the columns we want to drop from the data set my using a minus sign (-) in front of the columns we specify in the select() command. 

```{r}
new_data <- okcupid_profiles %>% select(-age, -height)
```

The glimpse() command shows us that we kept all the columns except the age and height columns when we created new_data.

```{r}
glimpse(new_data)
```


### summarise()

The summarise() command can be used to generate descriptive statistics for a specified column. You can easily calculate column descriptives using the corresponding commands for mean(), sd(), min(), max(), among others. In the example below we calculate the mean for the age column. To move to the next line while typing this command press SHIFT and ENTER (or RETURN) at the same time.

In code below mean(age, na.rm = TRUE) indicates that to R that it should calculate the mean of the age column. The na.rm indicates how missing values should be handled. The na stands for not available; in R missing values are classified as Not Available or NA. The rm stands for remove. Consequently, na.rm is asking should we remove missing values when calculating the mean. The TRUE indicates that yes, missing values should be removed when calculating the mean. The result of this calculation is place into a variable labelled age_mean, though we could have used any label we wanted instead of age_mean. We see that the mean of the age column is, with rounding, `r round(mean(okcupid_profiles$age, na.rm = TRUE),1)`.

```{r}
okcupid_profiles %>% 
  summarise(age_mean = mean(age, na.rm = TRUE))
```

More than one calculation can occur in the same summarise() command. You can easily add the calculation for the stanard deviation with the sd() command. 

```{r}
okcupid_profiles %>% 
  summarise(age_mean = mean(age, na.rm = TRUE),
            age_sd = sd(age, na.rm = TRUE))
```

We can use the n() command to also display the number of participants in the calculation:

```{r}
okcupid_profiles %>% 
  summarise(age_mean = mean(age, na.rm = TRUE),
            age_sd = sd(age, na.rm = TRUE),
            n = n())
```


### filter()

The filter() command allows you to obtain a subset of the rows in your data. In the example below we create a new data sets with just the males from the original data set.

Notice the structure of the original data set below in the glimpse() output. There is a column called sex that used m and f to indicate male and female, respectively. Also notice that there are `r dim(okcupid_profiles)[1]` rows in the okcupid_profiles data set.

```{r}
glimpse(okcupid_profiles)
```

We use the the filter command to select a subset of the rows based on the contents of any column. In this case the sex column. Notice the use of the the double equals sign to indicate "equal to". The reason a double equals sign is used here it to distinguish it from the use of the equals in the summarise command above were it was used to indicate "assign to" age_mean after the mean was calculated. Single equals sign indicates "assign to" whereas a double equals sign indicates "is equal to".

```{r}
okcupid_males <- okcupid_profiles %>%
  filter(sex == "m")
```

```{r, include = FALSE}
okcupid_females <- okcupid_profiles %>%
  filter(sex == "f")
```

We use glimpse() to inspect this all male data set. Notice that only the letter m is in the sex column. Also notice that there are `r dim(okcupid_males)[1]` rows in the okcupid_males data set; fewer people because only the males are in this data set.

```{r}
glimpse(okcupid_males)
```

The filter command can be commbined with the summarise command to get the descriptive statistics for males without the hassle of creating a new data set. This is done using the %>% "and then" operator.

```{r}
okcupid_profiles %>%
  filter(sex == "m") %>%
  summarise(age_mean = mean(age, na.rm = TRUE),
            age_sd = sd(age, na.rm = TRUE),
            n = n())
```

We see that for the `r dim(okcupid_males)[1]` females the mean age is `r sprintf("%1.1f",mean(okcupid_males$age))` and the standard deviation is `r sprintf("%1.1f",sd(okcupid_males$age))`.


Likewise, we can obtain the descriptive statistics for females with only a slight modification, changing m to f in the filter command:

```{r}
okcupid_profiles %>%
  filter(sex == "f") %>%
  summarise(age_mean = mean(age, na.rm = TRUE),
            age_sd = sd(age, na.rm = TRUE),
            n = n())
```

We see that for the `r dim(okcupid_females)[1]` females the mean age is `r sprintf("%1.1f",mean(okcupid_females$age))` and the standard deviation is `r sprintf("%1.1f",sd(okcupid_females$age))`.

### group_by()

The process we used with the filter command would quickly become onerous if we had many subgroups for a column. Consequently, it's often better to use the group() command to calculate descriptives for the levels of a variable. By telling the computer to group_by() sex the summarise command is run separately for every level of sex (i.e., m and f).

```{r}
okcupid_profiles %>%
  group_by(sex) %>%
  summarise(age_mean = mean(age, na.rm = TRUE),
            age_sd = sd(age, na.rm = TRUE),
            n = n()) 
```

Fortunately, it's possible to use more than one grouping varible with the group_by() command. In the code below we group by sex and status (i.e., dating status). 

```{r}
okcupid_profiles %>%
  group_by(sex, status) %>%
  summarise(age_mean = mean(age, na.rm = TRUE),
            age_sd = sd(age, na.rm = TRUE),
            n = n()) 
```

The resulting output provide for age the mean and standard deviation for every combination of sex and dating status. The first five rows provide output for females at every level of dating status whereas the subsequent five rows provide output for males at every level of dating status.


### mutate()

The mutate() command can be used to calculate a new column in the data set. 




## Advanced Tidyverse Commands

```{r}
library(tidyverse)
data_exp <- read_csv("data_experiment.csv")
```

```{r}
glimpse(data_exp)
```


### select()


#### select() using where()

```{r}
data_numeric_columns <- data_exp %>% 
  select(where(is.numeric))
```

```{r}
glimpse(data_numeric_columns)
```

```{r}
data_character_columns <- data_exp %>% 
  select(where(is.character))
```

```{r}
glimpse(data_character_columns)
```

#### select() using starts_with()

```{r}
data_time1 <- data_exp %>% 
  select(starts_with("time1_"))
```

```{r}
glimpse(data_time1)
```

#### select() using starts_with()

```{r}
data_aggression <- data_exp %>% 
  select(ends_with("_aggression"))
```

```{r}
glimpse(data_aggression)
```

#### select() using matches()

It's also possible to use *regex* (regular expressiona) to select columns. Regex is a powerful way to indicating search/matching requirements for text - in this case the text of column names. You can learn about regex at [RegexOne](https://regexone.com) and test your regex at [Regex101](https://regex101.com). Ideally though, as we discuss in the next chapter, you can use naming conventions are sufficiently considered you don't need regex or only rarely. The reason for this is that regex can be challenging to use. As Twitter user \@ThatJenPerson noted "Regex is like tequila: use it to try to solve a problem and now you have two problems." Nonetheless, at one or two points in the future we will use regex to solve a problem (but not tequila).



