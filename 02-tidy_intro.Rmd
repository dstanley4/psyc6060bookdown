# Handling Data with the Tidyverse

```{r, include=FALSE}
library(tidyverse)
```

## Required

The following packages must be installed before starting this chapter.

| Required Packages |
|-------------------|
|tidyverse          |

The following data files are used in this chapter:

| Required Data |
|-------------------|
|data_okcupid.csv   |
|data_experiment.csv   |

## Objective

The objective of this chapter is to familiarize you with some key commands in the tidyverse. The commands, as used in the chapter, and used in isolation of each other. In the next chapter we will use the commands in a more contextualized way as we load a data and move it from raw data to data that is ready for analysis (i.e., analytic data).


## Using the Console

All of the commands in this chapter should be typed into the Console within R. If you see a command split over multiple lines, use SHIFT-RETURN or SHIFT-ENTER to move the next line that is part of the same command. 


## Basic Tidyverse Commands

```{r, eval = FALSE}
library(tidyverse)
okcupid_profiles <- read_csv("data_okcupid.csv")
```

```{r, include = FALSE}
library(tidyverse)
okcupid_profiles <- read_csv("data_okcupid.csv")
```

You can see the first few rows of the data set using the print() command:

```{r}
print(okcupid_profiles)
```

But it's also helpful just to see a list of the columns in the data set with the glimpse() command:

```{r}
glimpse(okcupid_profiles)
```

### select()

The select() command allows you to obtain a subset of the columns in your data. The command below obtains can be used to obtain the age and height columns. You can read the command as: take the okcupid_profiles data and then select the age and height columns. You can see that this prints out the data with just the age and height columns.

```{r}
okcupid_profiles %>% select(age, height)
```


Of course, it's usually of little help to just print the subset of the data. It's better to store it in a new data set. In the command below we store the resulting data set in a data set called new_data.

```{r}
new_data <- okcupid_profiles %>% select(age, height)
```

The glimpse() command shows us that only the age and height columns are in new_data.

```{r}
glimpse(new_data)
```

In the above example we indicated the columns we wanted to retain from the okcupid_profiles data in the select() command. However, we can also indicate the columns we want to drop from the data set my using a minus sign (-) in front of the columns we specify in the select() command. 

```{r}
new_data <- okcupid_profiles %>% select(-age, -height)
```

The glimpse() command shows us that we kept all the columns except the age and height columns when we created new_data.

```{r}
glimpse(new_data)
```


### summarise()

The summarise() command can be used to generate descriptive statistics for a specified column. You can easily calculate column descriptives using the corresponding commands for mean(), sd(), min(), max(), among others. In the example below we calculate the mean for the age column. To move to the next line while typing this command press SHIFT and ENTER (or RETURN) at the same time.

In code below mean(age, na.rm = TRUE) indicates that to R that it should calculate the mean of the age column. The na.rm indicates how missing values should be handled. The na stands for not available; in R missing values are classified as Not Available or NA. The rm stands for remove. Consequently, na.rm is asking should we remove missing values when calculating the mean. The TRUE indicates that yes, missing values should be removed when calculating the mean. The result of this calculation is place into a variable labelled age_mean, though we could have used any label we wanted instead of age_mean. We see that the mean of the age column is, with rounding, `r round(mean(okcupid_profiles$age, na.rm = TRUE),1)`.

```{r}
okcupid_profiles %>% 
  summarise(age_mean = mean(age, na.rm = TRUE))
```

More than one calculation can occur in the same summarise() command. You can easily add the calculation for the stanard deviation with the sd() command. 

```{r}
okcupid_profiles %>% 
  summarise(age_mean = mean(age, na.rm = TRUE),
            age_sd = sd(age, na.rm = TRUE))
```


### filter()

The filter() command allows you to obtain a subset of the rows in your data. In the example below we create a new data sets with just the males from the original data set.

Notice the structure of the original data set below in the glimpse() output. There is a column called sex that used m and f to indicate male and female, respectively. Also notice that there are `r dim(okcupid_profiles)[1]` rows in the okcupid_profiles data set.

```{r}
glimpse(okcupid_profiles)
```

We use the the filter command to select a subset of the rows based on the contents of any column. In this case the sex column. Notice the use of the the double equals sign to indicate "equal to". The reason a double equals sign is used here it to distinguish it from the use of the equals in the summarise command above were it was used to indicate "assign to" age_mean after the mean was calculated. Single equals sign indicates "assign to" whereas a double equals sign indicates "is equal to".

```{r}
okcupid_males <- okcupid_profiles %>%
  filter(sex == "m")
```

```{r, include = FALSE}
okcupid_females <- okcupid_profiles %>%
  filter(sex == "f")
```

We use glimpse() to inspect this all male data set. Notice that only the letter m is in the sex column. Also notice that there are `r dim(okcupid_males)[1]` rows in the okcupid_males data set; fewer people because only the males are in this data set.

```{r}
glimpse(okcupid_males)
```

The filter command can be commbined with the summarise command to get the descriptive statistics for males without the hassle of creating a new data set. This is done using the %>% "and then" operator.

```{r}
okcupid_profiles %>%
  filter(sex == "m") %>%
  summarise(age_mean = mean(age, na.rm = TRUE),
            age_sd = sd(age, na.rm = TRUE))
```

We see that for the `r dim(okcupid_males)[1]` females the mean age is `r sprintf("%1.1f",mean(okcupid_males$age))` and the standard deviation is `r sprintf("%1.1f",sd(okcupid_males$age))`.


Likewise, we can obtain the descriptive statistics for females with only a slight modification, changing m to f in the filter command:

```{r}
okcupid_profiles %>%
  filter(sex == "f") %>%
  summarise(age_mean = mean(age, na.rm = TRUE),
            age_sd = sd(age, na.rm = TRUE))
```

We see that for the `r dim(okcupid_females)[1]` females the mean age is `r sprintf("%1.1f",mean(okcupid_females$age))` and the standard deviation is `r sprintf("%1.1f",sd(okcupid_females$age))`.

### group_by()

The process we used with the filter command would quickly become onerous if we had many subgroups for a column. Consequently, it's often better to use the group() command to calculate descriptives for the levels of a variable. By telling the computer to group_by() sex the summarise command is run separately for every level of sex (i.e., m and f).

```{r}
okcupid_profiles %>%
  group_by(sex) %>%
  summarise(age_mean = mean(age, na.rm = TRUE),
            age_sd = sd(age, na.rm = TRUE)) 
```

Fortunately, it's possible to use more than one grouping varible with the group_by() command. In the code below we group by sex and status (i.e., dating status). 

```{r}
okcupid_profiles %>%
  group_by(sex, status) %>%
  summarise(age_mean = mean(age, na.rm = TRUE),
            age_sd = sd(age, na.rm = TRUE)) 
```

The resulting output provide for age the mean and standard deviation for every combination of sex and dating status. The first five rows provide output for females at every level of dating status whereas the subsequent five rows provide output for males at every level of dating status.


### mutate()

The mutate() command can be used to calculate a new column in a data set.  In the example below we calculate a new column we call age_centered which is the new version of the age_column where the mean of the column has been removed from every value. Consequently, the mean of the new column, age_centered, is (within computer rounding) zero. This is merely an example of the many different types of calculations can can perform to create a new column using mutate().

```{r}
okcupid_profiles <- okcupid_profiles %>%
  mutate(age_centered = age - mean(age, na.rm = TRUE))
```

Notice that the glimpse() command reveals that after we use the mutate() command there is a new column called age_centered.

```{r}
glimpse(okcupid_profiles)
```

## Advanced Tidyverse Commands

In this advanced selection we will use more complicated code to either select or apply an action to more than one column at a time. We will indicate ths columns we want to select or apply an action to using: starts_with(), ends_with(), contains(), matches(), or where().  The first four of these apply to indicating columns with the contents of column names where as the last one, where(), indicates the column we want base on the column type (numeric, character, factor, etc.). You can learn more about one of these by simply typing into the console a question mark followed by the function name  (e.g., ?where) and then pressing return/enter.

We will review all five commands for indicating the columns we want in the select() selection below. Following that we will, for brevity, typically use only one of the five commands when illustrating how they work with summarise() and mutate().


We begin by loading a new data set.

```{r}
library(tidyverse)
data_exp <- read_csv("data_experiment.csv")

```

The glimpse() command reveals that this is a small data set where every row represents one rat. The sex of the rat is recorded as well as, for each of two time points, a rating of how frequently they vomitted or engaged in aggression.


```{r}
glimpse(data_exp)
```

### select()

#### select() using column name


##### starts_with()
starts_with() allows us to select columns based on how the column name begins. Here we put the columns that begin with "t1" into a new data set called data_time1.

```{r}
data_time1 <- data_exp %>% 
  select(starts_with("t1"))
```


The glimpse command shows us the new data set only contains the columns that begin with "t1"

```{r}
glimpse(data_time1)
```


##### ends_with()

ends_with() allows us to select columns based on how the column name ends. Here we put the columns that end with "aggression" into a new data set called data_aggression.

```{r}
data_aggression <- data_exp %>% 
  select(ends_with("aggression"))
```

```{r}
glimpse(data_aggression)
```

##### contains()

contains() allows us to select columns based on the contents of the column name. Here we put the columns that have "_" in the name into a new data set called new_data.

```{r}
new_data <- data_exp %>% 
  select(contains("_"))
```

```{r}
glimpse(new_data)
```


##### matches()

It's also possible to use *regex* (regular expressiona) to select columns. Regex is a powerful way to indicating search/matching requirements for text - in this case the text of column names. An explanation of regex is beyond the scope of this chapter. But the example below selects any column with and underscore in the column name followed by any character. The result is the same as the above for the contains() command. However, the matches() command is more flexible than the contains() command and can take into account substantially more complicated situations.

```{r}
data_matched<- data_exp %>% 
  select(matches("(_.)"))
```


You can see the columns selected using regex:


```{r}
glimpse(data_matched)
```

You can learn about regex at [RegexOne](https://regexone.com) and test your regex at [Regex101](https://regex101.com). Ideally though, as we discuss in the next chapter, you can use naming conventions that are sufficiently considered that you don't need regex, or only rarely. The reason for this is that regex can be challenging to use. As Twitter user \@ThatJenPerson noted "Regex is like tequila: use it to try to solve a problem and now you have two problems." Nonetheless, at one or two points in the future we will use regex to solve a problem (but not tequila).


#### select() using column type

If many cases we will want to select or perform on action on a column based on whether the column is a numeric, chractor, or factor columns (indicated in glimpse output as dbl, chr, and fct, respectively).  We will learn more about factor column in a subsequent chapter. Each of these column types can be selected by using is.numeric, is.character, or is.factor in combination with the where() command.

We can select numeric columns using where() and is.numeric:

```{r}
data_numeric_columns <- data_exp %>% 
  select(where(is.numeric))
```

You can see the new data set contains only the numeric columns:

```{r}
glimpse(data_numeric_columns)
```


We can select numeric columns using where() and is.character:

```{r}
data_character_columns <- data_exp %>% 
  select(where(is.character))
```

You can see the new data set contains only the character columns:

```{r}
glimpse(data_character_columns)
```

If a future chapter you will see how we can select factors using where(is.factor).


### summarise()

The summarise command becomes more powerful and can summarise multiple columns when combined with starts_with(), ends_with(), contains(), matches(), and where(). However, to use these powerful tools for indicating columns with the summarise command we need to help of the across command (i.e., across multiple columns).

If we want to obtain the mean of all the columns that start with "t1" we use the command below. The across command requires that we indicate the columns the columns we want via the .cols argument and the command/function we want to run of those columns via the .fns argument. In the example below, we also add na.rm = TRUE at the end; this is something we send to the mean command to let it know how we want to handle missing data.

```{r}
data_exp %>%
  summarise(across(.cols = starts_with("t1"), 
                   .fns = mean,
                   na.rm = TRUE))
```

If you want to get fancy, you can also add this .names argument below which tells R to call label each output mean by the column name followed by "_mean".

```{r}
data_exp %>%
  summarise(across(.cols = starts_with("t1"), 
                   .fns = mean,
                   na.rm = TRUE,
                   .names = "{col}_mean"))
```


Often you want more than one statistics for each column. You might want the mean, standard deviation, min, and max. Those statistics are available via the mean, sd, min, and max commands respectively. However, you need to create a list with the statistics you desired.

Below we create a list of the descriptive statistics we desire. This only needs to be done once, but I will repeat it in the examples below for clarity.
```{r}
desired_descriptives <- list(
  mean = ~mean(.x, na.rm = TRUE),
  sd = ~sd(.x, na.rm = TRUE)
)
```

Once you have created the list of descriptive statistics you want you can run the command below to obtain those statistics. However, as you will see the output is too wide to be helpful.

```{r}
data_exp %>%
  summarise(across(.cols = starts_with("t1"), 
                   .fns = desired_descriptives))
```

Consequently, we add the t() command (i.e., transpose command) to the end of the summarise request to get a more readable list of statistics:

```{r}
desired_descriptives <- list(
  mean = ~mean(.x, na.rm = TRUE),
  sd = ~sd(.x, na.rm = TRUE)
)

data_exp %>%
  summarise(across(.cols = starts_with("t1"), 
                   .fns = desired_descriptives)) %>%
  t()
```

Note that in the across command above we could also have used: ends_with(), contains(), matches(), or where().

### mutate()


```{r}
glimpse(data_exp)
```

```{r}

make_centered <- function(values) {
  values_out <- values - mean(values, na.rm = TRUE)
  return(values_out)
}
```


```{r}
data_exp <- data_exp %>% 
  mutate(across(.cols = ends_with("aggression"), 
                .fns = make_centered))

```


```{r}
glimpse(data_exp)
```

Note that in the across command above we could also have used: starts_with(), contains(), matches(), or where().

#### mutate() across rows

Researchers often want to average with rows and across columns to create a new column. To average within rows (and across columns) we have to tell R that we want mean using the rowwise() command. After we do the necessary operation though we have to shut off the rowwise() command by using the ungroup() command. As well, when we are averaging within rows we have to use c_across() instead of across(). The command below creates a new column called vomit_avg which the average of the vomit ratings across both times.

```{r}
data_exp <- data_exp %>% 
  rowwise() %>% 
  mutate(vomit_avg = mean( c_across(cols = ends_with("vomit")),
                               na.rm = TRUE)) %>%
  ungroup()
```

You can see the new column we created with the glimpse() command:

```{r}
glimpse(data_exp)
```

The print() command makes it easier to see the new column is the average of the other two.

```{r}
print(data_exp)
```


We can make it even easier to see by combining tidyverse commands and using only the commands colums we are interested in:

```{r}
data_exp %>%
  select(contains("vomit")) %>%
  print()
```

