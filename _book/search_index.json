[
["data-management-with-the-tidyverse.html", "Chapter 2 Data Management with the Tidyverse 2.1 Required Packages 2.2 Basic Tidyverse Commands 2.3 Advanced Tidyverse Commands", " Chapter 2 Data Management with the Tidyverse 2.1 Required Packages This chapter requires the following packages are installed: Required Packages tidyverse 2.2 Basic Tidyverse Commands library(tidyverse) okcupid_profiles &lt;- read_csv(&quot;data_okcupid.csv&quot;) You can see the first few rows of the data set using the print() command: print(okcupid_profiles) ## # A tibble: 59,946 x 6 ## age diet height pets sex status ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 22 strictly anything 75 likes dogs and likes cats m single ## 2 35 mostly other 70 likes dogs and likes cats m single ## 3 38 anything 68 has cats m available ## 4 23 vegetarian 71 likes cats m single ## 5 29 &lt;NA&gt; 66 likes dogs and likes cats m single ## 6 29 mostly anything 67 likes cats m single ## 7 32 strictly anything 65 likes dogs and likes cats f single ## 8 31 mostly anything 65 likes dogs and likes cats f single ## 9 24 strictly anything 67 likes dogs and likes cats f single ## 10 37 mostly anything 65 likes dogs and likes cats m single ## # … with 59,936 more rows But it’s also helpful just to see a list of the columns in the data set with the glimpse() command: glimpse(okcupid_profiles) ## Rows: 59,946 ## Columns: 6 ## $ age &lt;dbl&gt; 22, 35, 38, 23, 29, 29, 32, 31, 24, 37, 35, 28, 24, 30, 29, 39… ## $ diet &lt;chr&gt; &quot;strictly anything&quot;, &quot;mostly other&quot;, &quot;anything&quot;, &quot;vegetarian&quot;,… ## $ height &lt;dbl&gt; 75, 70, 68, 71, 66, 67, 65, 65, 67, 65, 70, 72, 72, 66, 62, 65… ## $ pets &lt;chr&gt; &quot;likes dogs and likes cats&quot;, &quot;likes dogs and likes cats&quot;, &quot;has… ## $ sex &lt;chr&gt; &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m… ## $ status &lt;chr&gt; &quot;single&quot;, &quot;single&quot;, &quot;available&quot;, &quot;single&quot;, &quot;single&quot;, &quot;single&quot;,… 2.2.1 select() The select() command allows you to obtain a subset of the columns in your data. The command below obtains can be used to obtain the age and height columns. You can read the command as: take the okcupid_profiles data and then select the age and height columns. You can see that this prints out the data with just the age and height columns. okcupid_profiles %&gt;% select(age, height) ## # A tibble: 59,946 x 2 ## age height ## &lt;dbl&gt; &lt;dbl&gt; ## 1 22 75 ## 2 35 70 ## 3 38 68 ## 4 23 71 ## 5 29 66 ## 6 29 67 ## 7 32 65 ## 8 31 65 ## 9 24 67 ## 10 37 65 ## # … with 59,936 more rows Of course, it’s usually of little help to just print the subset of the data. It’s better to store it in a new data set. In the command below we store the resulting data set in a data set called new_data. new_data &lt;- okcupid_profiles %&gt;% select(age, height) The glimpse() command shows us that only the age and height columns are in new_data. glimpse(new_data) ## Rows: 59,946 ## Columns: 2 ## $ age &lt;dbl&gt; 22, 35, 38, 23, 29, 29, 32, 31, 24, 37, 35, 28, 24, 30, 29, 39… ## $ height &lt;dbl&gt; 75, 70, 68, 71, 66, 67, 65, 65, 67, 65, 70, 72, 72, 66, 62, 65… In the above example we indicated the columns we wanted to retain from the okcupid_profiles data in the select() command. However, we also indicate the columns we want to drop from the data set my using a minus sign (-) in front of the columns we specify in the select() command. new_data &lt;- okcupid_profiles %&gt;% select(-age, -height) The glimpse() command shows us that we kept all the columns except the age and height columns when we created new_data. glimpse(new_data) ## Rows: 59,946 ## Columns: 4 ## $ diet &lt;chr&gt; &quot;strictly anything&quot;, &quot;mostly other&quot;, &quot;anything&quot;, &quot;vegetarian&quot;,… ## $ pets &lt;chr&gt; &quot;likes dogs and likes cats&quot;, &quot;likes dogs and likes cats&quot;, &quot;has… ## $ sex &lt;chr&gt; &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m… ## $ status &lt;chr&gt; &quot;single&quot;, &quot;single&quot;, &quot;available&quot;, &quot;single&quot;, &quot;single&quot;, &quot;single&quot;,… 2.2.2 summarise() The summarise() command can be used to generate descriptive statistics for a specified column. You can easily calculate column descriptives using the corresponding commands for mean(), sd(), min(), max(), among others. In the example below we calculate the mean for the age column. To move to the next line while typing this command press SHIFT and ENTER (or RETURN) at the same time. In code below mean(age, na.rm = TRUE) indicates that to R that it should calculate the mean of the age column. The na.rm indicates how missing values should be handled. The na stands for not available; in R missing values are classified as Not Available or NA. The rm stands for remove. Consequently, na.rm is asking should we remove missing values when calculating the mean. The TRUE indicates that yes, missing values should be removed when calculating the mean. The result of this calculation is place into a variable labelled age_mean, though we could have used any label we wanted instead of age_mean. We see that the mean of the age column is, with rounding, 32.3. okcupid_profiles %&gt;% summarise(age_mean = mean(age, na.rm = TRUE)) ## # A tibble: 1 x 1 ## age_mean ## &lt;dbl&gt; ## 1 32.3 More than one calculation can occur in the same summarise() command. You can easily add the calculation for the stanard deviation with the sd() command. okcupid_profiles %&gt;% summarise(age_mean = mean(age, na.rm = TRUE), age_sd = sd(age, na.rm = TRUE)) ## # A tibble: 1 x 2 ## age_mean age_sd ## &lt;dbl&gt; &lt;dbl&gt; ## 1 32.3 9.45 We can use the n() command to also display the number of participants in the calculation: okcupid_profiles %&gt;% summarise(age_mean = mean(age, na.rm = TRUE), age_sd = sd(age, na.rm = TRUE), n = n()) ## # A tibble: 1 x 3 ## age_mean age_sd n ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 32.3 9.45 59946 2.2.3 filter() The filter() command allows you to obtain a subset of the rows in your data. In the example below we create a new data sets with just the males from the original data set. Notice the structure of the original data set below in the glimpse() output. There is a column called sex that used m and f to indicate male and female, respectively. Also notice that there are 59946 rows in the okcupid_profiles data set. glimpse(okcupid_profiles) ## Rows: 59,946 ## Columns: 6 ## $ age &lt;dbl&gt; 22, 35, 38, 23, 29, 29, 32, 31, 24, 37, 35, 28, 24, 30, 29, 39… ## $ diet &lt;chr&gt; &quot;strictly anything&quot;, &quot;mostly other&quot;, &quot;anything&quot;, &quot;vegetarian&quot;,… ## $ height &lt;dbl&gt; 75, 70, 68, 71, 66, 67, 65, 65, 67, 65, 70, 72, 72, 66, 62, 65… ## $ pets &lt;chr&gt; &quot;likes dogs and likes cats&quot;, &quot;likes dogs and likes cats&quot;, &quot;has… ## $ sex &lt;chr&gt; &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m… ## $ status &lt;chr&gt; &quot;single&quot;, &quot;single&quot;, &quot;available&quot;, &quot;single&quot;, &quot;single&quot;, &quot;single&quot;,… We use the the filter command to select a subset of the rows based on the contents of any column. In this case the sex column. Notice the use of the the double equals sign to indicate “equal to”. The reason a double equals sign is used here it to distinguish it from the use of the equals in the summarise command above were it was used to indicate “assign to” age_mean after the mean was calculated. Single equals sign indicates “assign to” whereas a double equals sign indicates “is equal to”. okcupid_males &lt;- okcupid_profiles %&gt;% filter(sex == &quot;m&quot;) We use glimpse() to inspect this all male data set. Notice that only the letter m is in the sex column. Also notice that there are 35829 rows in the okcupid_males data set; fewer people because only the males are in this data set. glimpse(okcupid_males) ## Rows: 35,829 ## Columns: 6 ## $ age &lt;dbl&gt; 22, 35, 38, 23, 29, 29, 37, 35, 28, 24, 33, 31, 33, 30, 30, 33… ## $ diet &lt;chr&gt; &quot;strictly anything&quot;, &quot;mostly other&quot;, &quot;anything&quot;, &quot;vegetarian&quot;,… ## $ height &lt;dbl&gt; 75, 70, 68, 71, 66, 67, 65, 70, 72, 72, 70, 71, 72, 69, 71, 73… ## $ pets &lt;chr&gt; &quot;likes dogs and likes cats&quot;, &quot;likes dogs and likes cats&quot;, &quot;has… ## $ sex &lt;chr&gt; &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m… ## $ status &lt;chr&gt; &quot;single&quot;, &quot;single&quot;, &quot;available&quot;, &quot;single&quot;, &quot;single&quot;, &quot;single&quot;,… The filter command can be commbined with the summarise command to get the descriptive statistics for males without the hassle of creating a new data set. This is done using the %&gt;% “and then” operator. okcupid_profiles %&gt;% filter(sex == &quot;m&quot;) %&gt;% summarise(age_mean = mean(age, na.rm = TRUE), age_sd = sd(age, na.rm = TRUE), n = n()) ## # A tibble: 1 x 3 ## age_mean age_sd n ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 32.0 9.03 35829 We see that for the 35829 females the mean age is 32.0 and the standard deviation is 9.0. Likewise, we can obtain the descriptive statistics for females with only a slight modification, changing m to f in the filter command: okcupid_profiles %&gt;% filter(sex == &quot;f&quot;) %&gt;% summarise(age_mean = mean(age, na.rm = TRUE), age_sd = sd(age, na.rm = TRUE), n = n()) ## # A tibble: 1 x 3 ## age_mean age_sd n ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 32.8 10.0 24117 We see that for the 24117 females the mean age is 32.8 and the standard deviation is 10.0. 2.2.4 group_by() The process we used with the filter command would quickly become onerous if we had many subgroups for a column. Consequently, it’s often better to use the group() command to calculate descriptives for the levels of a variable. By telling the computer to group_by() sex the summarise command is run separately for every level of sex (i.e., m and f). okcupid_profiles %&gt;% group_by(sex) %&gt;% summarise(age_mean = mean(age, na.rm = TRUE), age_sd = sd(age, na.rm = TRUE), n = n()) ## `summarise()` ungrouping output (override with `.groups` argument) ## # A tibble: 2 x 4 ## sex age_mean age_sd n ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 f 32.8 10.0 24117 ## 2 m 32.0 9.03 35829 Fortunately, it’s possible to use more than one grouping varible with the group_by() command. In the code below we group by sex and status (i.e., dating status). okcupid_profiles %&gt;% group_by(sex, status) %&gt;% summarise(age_mean = mean(age, na.rm = TRUE), age_sd = sd(age, na.rm = TRUE), n = n()) ## `summarise()` regrouping output by &#39;sex&#39; (override with `.groups` argument) ## # A tibble: 10 x 5 ## # Groups: sex [2] ## sex status age_mean age_sd n ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 f available 32.2 8.54 656 ## 2 f married 33.7 8.13 135 ## 3 f seeing someone 28.1 6.44 1003 ## 4 f single 33.0 10.2 22319 ## 5 f unknown 27.8 5.91 4 ## 6 m available 34.8 9.40 1209 ## 7 m married 38.7 10.1 175 ## 8 m seeing someone 30.8 7.06 1061 ## 9 m single 31.9 9.04 33378 ## 10 m unknown 40.7 8.87 6 The resulting output provide for age the mean and standard deviation for every combination of sex and dating status. The first five rows provide output for females at every level of dating status whereas the subsequent five rows provide output for males at every level of dating status. 2.2.5 mutate() The mutate() command can be used to calculate a new column in the data set. 2.3 Advanced Tidyverse Commands library(tidyverse) data_exp &lt;- read_csv(&quot;data_experiment.csv&quot;) ## Parsed with column specification: ## cols( ## id = col_double(), ## sex = col_character(), ## time1_vomit = col_double(), ## time1_aggression = col_double(), ## time2_vomit = col_double(), ## time2_aggression = col_double() ## ) glimpse(data_exp) ## Rows: 6 ## Columns: 6 ## $ id &lt;dbl&gt; 1, 2, 3, 4, 5, 6 ## $ sex &lt;chr&gt; &quot;male&quot;, &quot;female&quot;, &quot;male&quot;, &quot;female&quot;, &quot;male&quot;, &quot;female&quot; ## $ time1_vomit &lt;dbl&gt; 3, 2, 0, 3, 2, 1 ## $ time1_aggression &lt;dbl&gt; 5, 6, 4, 7, 3, 8 ## $ time2_vomit &lt;dbl&gt; 2, 1, 1, 2, 1, 2 ## $ time2_aggression &lt;dbl&gt; 6, 7, 6, 7, 5, 8 2.3.1 select() 2.3.1.1 select() using where() data_numeric_columns &lt;- data_exp %&gt;% select(where(is.numeric)) glimpse(data_numeric_columns) ## Rows: 6 ## Columns: 5 ## $ id &lt;dbl&gt; 1, 2, 3, 4, 5, 6 ## $ time1_vomit &lt;dbl&gt; 3, 2, 0, 3, 2, 1 ## $ time1_aggression &lt;dbl&gt; 5, 6, 4, 7, 3, 8 ## $ time2_vomit &lt;dbl&gt; 2, 1, 1, 2, 1, 2 ## $ time2_aggression &lt;dbl&gt; 6, 7, 6, 7, 5, 8 data_character_columns &lt;- data_exp %&gt;% select(where(is.character)) glimpse(data_character_columns) ## Rows: 6 ## Columns: 1 ## $ sex &lt;chr&gt; &quot;male&quot;, &quot;female&quot;, &quot;male&quot;, &quot;female&quot;, &quot;male&quot;, &quot;female&quot; 2.3.1.2 select() using starts_with() data_time1 &lt;- data_exp %&gt;% select(starts_with(&quot;time1_&quot;)) glimpse(data_time1) ## Rows: 6 ## Columns: 2 ## $ time1_vomit &lt;dbl&gt; 3, 2, 0, 3, 2, 1 ## $ time1_aggression &lt;dbl&gt; 5, 6, 4, 7, 3, 8 2.3.1.3 select() using starts_with() data_aggression &lt;- data_exp %&gt;% select(ends_with(&quot;_aggression&quot;)) glimpse(data_aggression) ## Rows: 6 ## Columns: 2 ## $ time1_aggression &lt;dbl&gt; 5, 6, 4, 7, 3, 8 ## $ time2_aggression &lt;dbl&gt; 6, 7, 6, 7, 5, 8 2.3.1.4 select() using matches() It’s also possible to use regex (regular expressiona) to select columns. Regex is a powerful way to indicating search/matching requirements for text - in this case the text of column names. You can learn about regex at RegexOne and test your regex at Regex101. Ideally though, as we discuss in the next chapter, you can use naming conventions are sufficiently considered you don’t need regex or only rarely. The reason for this is that regex can be challenging to use. As Twitter user @ThatJenPerson noted “Regex is like tequila: use it to try to solve a problem and now you have two problems.” Nonetheless, at one or two points in the future we will use regex to solve a problem (but not tequila). "]
]
